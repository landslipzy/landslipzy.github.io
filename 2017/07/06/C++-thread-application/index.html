<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="学习使我快乐">
    <meta name="keywords"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>C++ 多线程应用篇 - 彭侦的博客 | PengZhen's Blog</title>

    <link rel="canonical" href="https://chorior.github.io/2017/07/06/C++-thread-application/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <!--<link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">-->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">PengZhen's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __FishNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __FishNav__.close()
        }else{
            __FishNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close FishNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __FishNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/stock-photo-7.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/stock-photo-7.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#C++" title="C++">C++</a>
                        
                        <a class="tag" href="/tags/#thread" title="thread">thread</a>
                        
                    </div>
                    <h1>C++ 多线程应用篇</h1>
                    
                    
                    <h2 class="subheading">并发代码设计、管理及调试</h2>
                    
                    <span class="meta">Posted by pengzhen on July 6, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<p>本文知识来自<a href="https://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/">C++ Concurrency In Action</a>，介绍有关C++11多线程(multithreading)相关的代码设计、管理及调试的知识。</p>

<h1 id="section">本文结构</h1>

<ul>
  <li><a href="#design_concurrent_code">并发代码设计</a>
    <ul>
      <li><a href="#data_based_work_division">基于数据的工作划分</a></li>
      <li><a href="#task_type_based_work_division">基于任务类型的工作划分</a></li>
      <li><a href="#factors_affecting_the_performance_of_concurrent_code">影响并发代码性能的因素</a></li>
      <li><a href="#designing_data_structures_for_multithreaded_performance">为多线程性能设计数据结构</a></li>
      <li><a href="#additional_considerations_when_designing_for_concurrency">多线程设计时的其它注意事项</a></li>
      <li><a href="#improving_responsiveness_with_concurrency">多线程改善响应能力</a></li>
      <li><a href="#std_for_each">std::for_each</a></li>
      <li><a href="#std_find">std::find</a></li>
      <li><a href="#std_partial_sum">std::partial_sum</a></li>
    </ul>
  </li>
  <li><a href="#advanced_thread_management">高级线程管理</a>
    <ul>
      <li><a href="#thread_pool">线程池(thread pool)</a></li>
      <li><a href="#interrupting_threads">线程中断</a></li>
    </ul>
  </li>
  <li><a href="#testing_and_debugging_multithreaded_applications">多线程程序的测试与调试</a>
    <ul>
      <li><a href="#types_of_concurrency_related_bugs">与并发相关的错误类型</a></li>
      <li><a href="#techniques_for_locating_concurrency_related_bugs">查找并发相关错误的技术</a></li>
    </ul>
  </li>
</ul>

<h2 id="design_concurrent_code">并发代码设计</h2>

<p><strong>并发代码的设计比基本数据结构的设计和使用要频繁的多</strong>，要将眼界放宽，才能构建出能有效工作的更大的架构。在写多线程代码时，你不仅需要考虑一般因素，如封装、继承、友元等等，你还需要考虑哪些数据需要被共享、如何同步这些数据、哪些线程需要等待哪些另外的线程，等等。</p>

<p>在代码设计时，你需要考虑要用多少个线程、每个线程做什么工作、是使用“全能”(什么工作都能做)的线程还是“专业”(只能做一种工作)的线程，还是混合着使用，这些选择将决定你代码的性能和清晰度。</p>

<h3 id="data_based_work_division">基于数据的工作划分</h3>

<p>最简单的并行算法是<code class="highlighter-rouge">std::for_each</code>，它对一个数据集中的每个元素执行相同的操作。为了并发这个算法，你可以为每个元素都分配一个处理线程。如何划分才能获得最大的优化性能很大程度上决定于数据结构的实现细节。最简单的方式是为每个线程分配最多N个元素，但是不管如何划分，每个线程都只管自己分配到的元素，直到操作完成前，没有任何与其他线程的通信。使用过<a href="http://mpi-forum.org/">MPI(Message Passing Interface)</a>或<a href="http://www.openmp.org/">openMP</a>架构的人应该非常熟悉：一个任务被划分为一个并行任务集，工作线程独立的执行这些任务，并将结果合并到最终的还原步骤中去。还原步骤就像<code class="highlighter-rouge">accumulate</code>一样，只不过<code class="highlighter-rouge">accumulate</code>是累加，结果的合并可能会有所不同。</p>

<p>有时候任务并不能被整洁的划分，因为数据可能只有在运行时才能被明确的划分，但这非常适用于递归算法，如快速排序。</p>

<p>快速排序的基本思想是：随意挑选一个元素，然后将集合中的所有元素按小于该元素和大于该元素分为两组，对两组元素分别再执行上诉操作，如此递归循环，最后将排序集合并，即为最终排序后的集合。你不能简单的划分数据来使其并行，因为分组是运行时才决定的，如果你一定要并行这种算法的话，很自然的你就会想到递归。由于不得不对前后两组分别进行排序，所以每次递归都会更多次的调用<code class="highlighter-rouge">quick_sort</code>函数，这些递归调用是完全独立的，因为它们访问的是不同元素的数据集，所以可以并发调用。</p>

<p>在<a href="https://chorior.github.io/2017/04/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/#functional_program_with_future">基础篇</a>中，我们实现了一个并发的快速排序，使用<code class="highlighter-rouge">std::async</code>可以要求C++标准库来决定何时在一个新线程上执行任务，以及何时同步执行它。这是非常重要的，因为太多线程可能会导致你的应用程序变得很慢。在递归函数中使用这样的方式是非常好的，你只需要注意线程的数量，而<code class="highlighter-rouge">std::async</code>可以帮你处理这个问题，但这不是唯一的方式。</p>

<p>一个替代的方案就是使用<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>函数来选择线程的数量，然后，除了为每个递归调用开启一个新线程，你可以将要排序的数据块push到<a href="https://chorior.github.io/2017/05/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/#stack">一个线程安全stack</a>中去，如果一个线程没有事做，它要么已经完成了交给它的数据块的排序，要么正在等待数据块进行排序，它可以从stack中获取一个数据块，并对它们进行排序。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;random&gt;
#include &lt;cstdlib&gt;
</span>
<span class="cp">#include "myQuickSort.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myList</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">myList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">res1</span> <span class="o">=</span> <span class="n">sequential_quick_sort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"seq: "</span> 
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> 
		<span class="o">&lt;&lt;</span> <span class="s">"ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">res2</span> <span class="o">=</span> <span class="n">parallel_quick_sort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">myList</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"par: "</span> 
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> 
		<span class="o">&lt;&lt;</span> <span class="s">"ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="cm">/*for (auto &amp;i : res2)
	{
	std::cout &lt;&lt; i &lt;&lt; std::ends;
	}*/</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// myQuickSort.h
</span><span class="cp">#pragma once
</span>
<span class="cp">#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;vector&gt;
#include &lt;atomic&gt;
#include &lt;algorithm&gt;
#include &lt;future&gt;
</span><span class="c1">//#include &lt;boost\smart_ptr\shared_ptr.hpp&gt;
</span>
<span class="cp">#include "myStack.h"
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">sorter</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">chunk_to_sort</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">promise</span><span class="p">;</span>
	<span class="p">};</span>

	<span class="n">threadsafe_stack</span><span class="o">&lt;</span><span class="n">chunk_to_sort</span><span class="o">&gt;</span> <span class="n">chunks</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">max_thread_count</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">end_of_data</span><span class="p">;</span>

	<span class="n">sorter</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">max_thread_count</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		<span class="n">end_of_data</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">sorter</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">end_of_data</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">try_sort_chunk</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">try</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">chunk</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">sort_chunk</span><span class="p">(</span><span class="n">chunk</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">empty_stack</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//std::cout &lt;&lt; e.what();
</span>			<span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span> <span class="c1">// 删除会跳出warning: 未引用的局部变量
</span>		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">chunk_data</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk_data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">chunk_data</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
		<span class="c1">// l.splice(iterator pos,list&amp; x, iterator i)
</span>		<span class="c1">// 将x中i指向的元素移动插入到l中pos指向的位置之前
</span>		<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">chunk_data</span><span class="p">,</span> <span class="n">chunk_data</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
		<span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">partition_val</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

		<span class="c1">// std::partition(iterator beg, iterator end, func)
</span>		<span class="c1">// 将[beg,end)中的元素按func分为两组，第一组使func返回true，第二组使func返回false
</span>		<span class="c1">// 返回分组后指向第二组的第一个元素的迭代器，不保证原有元素的顺序
</span>		<span class="k">auto</span> <span class="n">divide_point</span> <span class="o">=</span>
			<span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">chunk_data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">chunk_data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="n">partition_val</span><span class="p">;</span> <span class="p">});</span>

		<span class="n">chunk_to_sort</span> <span class="n">new_lower_chunk</span><span class="p">;</span>
		<span class="c1">// l.splice(iterator pos, list&amp; x, iterator beg, iterator end)
</span>		<span class="c1">// 将x中[beg,end)范围内元素移动插入到l中pos指向的位置之前
</span>		<span class="n">new_lower_chunk</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">new_lower_chunk</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="n">chunk_data</span><span class="p">,</span> <span class="n">chunk_data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">divide_point</span><span class="p">);</span>

		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">new_lower</span> <span class="o">=</span>
			<span class="n">new_lower_chunk</span><span class="p">.</span><span class="n">promise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
		<span class="n">chunks</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_lower_chunk</span><span class="p">));</span> <span class="c1">// 将new_lower_chunk压入到stack
</span>
		<span class="c1">// 如果当前线程数小于允许的最大线程数，就继续开启一个排序线程
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">max_thread_count</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sorter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">sort_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">new_higher</span><span class="p">(</span><span class="n">do_sort</span><span class="p">(</span><span class="n">chunk_data</span><span class="p">));</span>
		<span class="c1">// l.splice(iterator pos, list&amp; x)
</span>		<span class="c1">// 将x中所有元素移动插入到l中pos指向的位置之前
</span>		<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">new_higher</span><span class="p">);</span>

		<span class="c1">// 等待lower part完成排序。如果lower part还未完成或者还没开始，
</span>		<span class="c1">// 反正没事做，不如尝试在本线程内把别人的或自己的lower part也做了
</span>		<span class="c1">// 如果chunks为空，但是lower part还未完成，chunks.pop就会抛出empty_stack异常
</span>		<span class="k">while</span> <span class="p">(</span><span class="n">new_lower</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">!=</span>
			<span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">try_sort_chunk</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_lower</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">sort_chunk</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">chunk_to_sort</span> <span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">chunk</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">chunk</span><span class="o">-&gt;</span><span class="n">promise</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">do_sort</span><span class="p">(</span><span class="n">chunk</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">sort_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">end_of_data</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">try_sort_chunk</span><span class="p">();</span>
			<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sorter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">do_sort</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="c1">// l.splice(iterator pos,list&amp; x, iterator i)
</span>	<span class="c1">// 将x中i指向的元素移动插入到l中pos指向的位置之前
</span>	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
	<span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pivot</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

	<span class="c1">// std::partition(iterator beg, iterator end, func)
</span>	<span class="c1">// 将[beg,end)中的元素按func分为两组，第一组使func返回true，第二组使func返回false
</span>	<span class="c1">// 返回分组后指向第二组的第一个元素的迭代器，不保证原有元素的顺序
</span>	<span class="k">auto</span> <span class="n">divide_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
		<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">pivot</span><span class="p">;</span> <span class="p">});</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lower_part</span><span class="p">;</span>
	<span class="c1">// l.splice(iterator pos,list&amp; x, iterator beg, iterator end)
</span>	<span class="c1">// 将x中[beg,end)范围内元素移动插入到l中pos指向的位置之前
</span>	<span class="n">lower_part</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lower_part</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">divide_point</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">new_lower</span><span class="p">(</span>
		<span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lower_part</span><span class="p">)));</span>
	<span class="k">auto</span> <span class="n">new_higher</span><span class="p">(</span>
		<span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">input</span><span class="p">)));</span>

	<span class="c1">// l.splice(iterator pos,list&amp; x)
</span>	<span class="c1">// 将x中所有元素移动插入到l中pos指向的位置之前
</span>	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">new_higher</span><span class="p">);</span>
	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_lower</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// myStack.h
</span><span class="cp">#pragma once
</span>
<span class="c1">// 一个线程安全的简单stack模板
</span><span class="cp">#include &lt;exception&gt;
#include &lt;stack&gt;
#include &lt;mutex&gt;
</span>
<span class="k">struct</span> <span class="n">empty_stack</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">"empty stack.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe</span><span class="n">_stack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">threadsafe_stack</span><span class="p">()</span> <span class="p">{}</span>

	<span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_value</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span>
		<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">res</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">())));</span>
		<span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">());</span>
		<span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>seq: 78.2769ms
par: 53.8802ms

</code></pre>
</div>

<p>分析：</p>

<ul>
  <li>上面程序中，<code class="highlighter-rouge">threadsafe_stack</code>很简单，对每个成员函数上锁然后进行操作；</li>
  <li><code class="highlighter-rouge">sequential_quick_sort</code>也很容易理解，一般的递归程序，关键部分也写了注释(注意splice的功能是移动而不是复制)；</li>
  <li>比较难懂的就是<code class="highlighter-rouge">parallel_quick_sort</code>了，它首先调用了sorter的<code class="highlighter-rouge">do_sort</code>函数，该函数与<code class="highlighter-rouge">sequential_quick_sort</code>类似，但是将lower部分交给了另一个线程，如果不考虑线程的启动时间和线程数的限制的话，理论上会比<code class="highlighter-rouge">sequential</code>快一倍；与使用<code class="highlighter-rouge">std::async</code>不同，该实现使用<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>来控制线程的最大数量，而不是标准库自行决定；当<code class="highlighter-rouge">do_sort</code>完成之后，<code class="highlighter-rouge">parallel_quick_sort</code>会进行return，所以<code class="highlighter-rouge">sorter&lt;T&gt; s</code>会进行析构，停止所有的工作线程(<code class="highlighter-rouge">end_of_data = true</code>)，并对thread进行清理(join)；一个潜在的问题就是：线程管理及线程间通讯，要解决这两个问题就要增加代码相当大的复杂程度；另外一个问题是：所有的添加和移除都是通过访问stack来完成的，这造成了强烈的竞争，并且会降低性能，也许你想使用无锁的stack会不会解决这个问题，答案是no。</li>
</ul>

<p>上面的方案就是一个特殊版本的线程池(thread pool)–所有线程的任务都来源于一个等待列表，然后线程会去完成任务，完成任务后会再来列表提取任务。这样的线程池有一些潜在的问题(包括对等待列表的竞争)，如何解决这些问题，将在后面进行讲解。</p>

<p>现在我们有两种方式来划分数据了：一种是在处理开始前、一种是在数据长度固定的情况下进行递归划分。但是并不是所有情况都能这样解决，当数据是动态生成的、或者数据是从外部输入的时候，就不能这样做了，这种情况就需要基于任务类型的划分方式了。</p>

<h3 id="task_type_based_work_division">基于任务类型的工作划分</h3>

<p>基于数据的工作划分是在假设每个线程在分配的数据块上做相同的操作的情况下进行的；另一种划分工作的方式就是使线程变得“专业化”，每个线程执行完全不同的操作，可能会有多个线程工作在同一个数据块上，但是却执行完全不同的操作；这是使用并发分离关注点的结果，每个线程都有一个不同的任务，它独立于其他线程执行；也许偶尔会有其他线程给它传数据，或者触发它需要处理的事件，但是一般来说，每个线程都着重于做一件事情，每段代码只对自己的部分负责。</p>

<h4 id="dividing-work-by-task-type-to-separate-concerns">DIVIDING WORK BY TASK TYPE TO SEPARATE CONCERNS</h4>

<p>单线程中，当有多个任务需要在一段时间内连续不断的运行时，或者程序在其它任务正在进行的情况下仍然需要能够及时处理输入事件(如用户键盘输入、网络数据输入等)时，程序不得不使用单一责任原则(single responsibility principle)来处理这些冲突。在单线程世界里，要处理上面的场景，程序需要先处理一部分任务A，再处理一部分任务B，然后检查是否有用户输入、检查是否有网络数据输入，然后再循环回去继续执行另一部分的任务A…这意味着任务A会变得复杂化，因为它不得不保存它的状态信息，并周期性的返回到主循环中；如果你添加了太多任务到这个循环中，那么用户输入的响应就会变得很慢。有个特殊形式的这种情况相信很多人都见过：当你使程序做一项任务时，接口封锁直到任务完成。</p>

<p>这就是线程诞生的地方。如果你在不同线程中运行每个任务，那么操作系统会为你处理上面的问题。在任务A的代码里，你只需要专注于如何完成这个任务，而不用担心状态的保存、返回到主循环、更不用担心你做这个任务花费了多少时间。操作系统会在适当的时候帮你保存状态，然后切换到任务B或任务C(任务切换)，如果系统拥有多个内核或处理器的话，任务A和B也许可以达到真正的并发(硬件并发)。现在用户等到及时响应了，作为开发者你也简化了自己的代码，因为每个线程都可以专注于直接与其职责相关的操作，再也不必将控制分支与用户交互混合在一起了。</p>

<p>这听起来很美好，但是真的能够实现么？如果所有任务都是相互独立的，线程间也不必相互通信，那么它就是这么easy。然而不幸的是，现实并没有那么美好，这些美好的后台线程经常被要求做一些用户要求做的事情，并且他们需要通过以某种方式更新用户界面来让用户知道他们什么时候完成；或者用户可能想要取消或停止某个后台线程。这两个场景都需要小心的思考、设计并适当的同步，但是<strong>关注的问题仍然是分离的(the concerns are still separate)</strong>：用户接口线程仍然只需要处理用户输入，但是它可能在被其它线程要求做某件事时发生更新；同样的，后台任务仍然只需要关注其任务的实现，只是有时会发生“允许任务被其他线程停止”的情况。</p>

<p>你可能会分离成错误的关注点，线程间共享了大量的数据，或不同线程间相互等待，这两种情况都归结为线程间使用了太多的通信。<strong>如果所有的通信都涉及到相同的问题，也许是一个线程的关键责任，应该从引用它的所有线程中提取出来；或者如果两个线程通信很密切，但是与其它线程却通信很少，也许它们应该被合并在同一个线程中</strong>；</p>

<p><strong>当使用任务类型来划分工作时，你不必将自己限制在完全独立的情况下，如果多组输入数据需要相同的操作顺序，你可以将序列中的操作分成多个阶段(stage)，然后分配给每个线程</strong>。</p>

<h4 id="dividing-a-sequence-of-tasks-between-threads">DIVIDING A SEQUENCE OF TASKS BETWEEN THREADS</h4>

<p><strong>如果你的任务包括将相同的操作序列应用于许多独立的数据项，则可以使用流水线(pipeline)来利用系统可用的并发性</strong>。这好比一个物理管道：数据流从管道一端进入，在进行一系列操作后，从管道另一端出去。你可以为流水线的每个操作创建一个单独的线程：当一个操作完成之后，数据被放到一个队列中，然后被下一个线程获取。这允许序列中执行第一个操作的线程在开始做下一个数据项的时候，序列中执行第二个操作的线程正在做前一个数据项。这样的划分方式不仅适用于所有数据已知的情况，同样也适用于当操作开始后输入数据不是全部已知的情况。例如，数据可能通过网络进入，或者序列中的第一个操作可能用于扫描文件系统以识别要处理的文件。</p>

<p>通过在线程间划分工作而非数据，你改变了实现的属性。假设您有20个数据项要处理，在四个内核上，每个数据项需要四个步骤，每个步骤需要3秒钟。如果您在四个线程之间划分数据，那么每个线程都有5个数据项要处理，假设没有其他可能会影响时间的处理，12秒后，你将处理4个数据项，那么所有20个数据项一共需要60秒；如果你使用流水线(pipeline)的话，这四个步骤可以被分配到每个内核，现在第一个数据项会被每个内核处理，所以仍然需要12秒，然而12秒之后，一个数据项只需要3秒即可被处理，所以现在全部完成就需要3*19+12=69秒，发现多了9秒，原因是最后一个内核在开始处理第一个数据项时，不得不等待9秒。</p>

<p><strong>在一些情况下，更平稳，更固定的处理可能是有益的</strong>。例如，考虑一个观看高分辨率数字视频的系统，为了让视频可以观看，通常需要每秒至少25帧或者更多，用户需要这些均匀间隔以给人持续运动的印象。如果还是四个内核，每个内核每秒能处理25帧，那么使用划分数据的方式，每暂停一秒钟，就会显示100帧，然后再暂停一秒钟，显示另外100帧；另一方面，使用流水线的话，虽然一开始会有一定时间的延迟，但是后面每秒都会稳定的显示25帧。用户可能很乐意在开始观看视频前延迟几秒钟，在这种情况下，使用以良好的稳定速率输出帧的管道进行并行化可能会更好。</p>

<h3 id="factors_affecting_the_performance_of_concurrent_code">影响并发代码性能的因素</h3>

<p><strong>处理器的数量是影响多线程程序性能的一个至关重要的因素</strong>。如果你对目标硬件非常熟悉，那么你可以针对硬件进行设计，但是大多数情况下并不是这样–你可能在一个类似的系统上进行开发，所以与目标系统的差异就显得至关重要了。例如，你在一个双核或者四核的系统上进行开发，但是用户的系统却只有一个多核处理器(带有多个内核)、或者多个单核处理器、甚至多个多核处理器，<strong>在不同平台上，并发程序的行为和性能特点就可能完全不同，所以你需要仔细考虑那些地方会被影响到，如果会被影响，就需要在不同平台上进行测试</strong>。</p>

<p>一个16核处理器与4个四核处理器或16个单核处理器相同–可以同时运行16个线程。如果你想利用这一点，你的程序必须拥有至少16个线程；少于16个将会有空闲的处理器(不考虑其他程序运行的消耗)，但是多于16个将会浪费处理器的运算时间在线程间的任务切换上，这被称为<strong>超额认购(oversubscription)</strong>。为了允许应用程序根据硬件可以同时运行的线程数量来扩展线程数，C++11标准线程库提供了<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>，本文最开始的示例也展示了对该函数的使用。</p>

<p><strong>直接使用<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>需要特别小心，因为代码不会考虑其它运行在该系统上的线程，除非你分享了这个信息</strong>。最坏的情况是：<strong>如果有多个线程同时调用了一个使用了<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>的函数来扩展线程数，就会导致庞大的超额认购(oversubscription)</strong>。<code class="highlighter-rouge">std::async()</code>可以避免这个问题，因为标准库知道所有的调用，并能进行适当的安排；小心使用线程池也能避免这个问题。</p>

<p>但是，<strong>即使你考虑到应用程序中运行的所有线程，仍然会受到同时运行的其他应用程序的影响</strong>。一个选项是使用与<code class="highlighter-rouge">std::async()</code>类似的工具，来为所有执行异步任务的线程的数量做考虑;另一个选项是限制给定应用程序可以使用的处理核心数量。</p>

<p>一个问题的理想算法可能取决于该问题的规模与处理单元数的比值，如果你有一个具有许多处理单元的大规模并行系统，那么整体执行较多操作的算法可能会比执行较少操作的算法更快完成，因为每个处理器只执行很少的操作。</p>

<h4 id="data-contention-and-cache-ping-pong">Data contention and cache ping-pong</h4>

<p>如果两个线程在两个不同的处理器上同时运行，并且它们都只读相同的数据，这通常不会造成问题，因为数据可以被拷贝到各自的缓冲中去；然而，如果有线程修改数据的话，这个修改就需要被更新到其它内核的缓冲区中去，这需要消耗一些时间。根据两个线程上的操作的性质以及用于操作的存储顺序(memory order)，这样的修改可能会让第二个处理器停下来，等待硬件内存更新缓存中的数据。在CPU指令方面，这可能是一个非常慢的操作，相当于数百个单独的指令，尽管精确的时序主要取决于硬件的物理结构。</p>

<p>考虑如下代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">processing_loop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">100000000</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">do_something</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>counter是全局的，所以任何调用<code class="highlighter-rouge">processing_loop</code>的线程都在修改同一个变量，因此，处理器必须确保其缓存中的counter拷贝是最新的，然后修改这个值，并发布到其它处理器，即使你使用的是<code class="highlighter-rouge">std::memory_order_relaxed</code>。如果另一个处理器上的另一个线程在运行相同的代码，那么counter就必须在两个处理期间来回传递，这样当counter做递增操作时，两个处理器缓存中就会有最新的值；如果<code class="highlighter-rouge">do_something()</code>足够短，或者有太多处理器在运行这段程序，那么处理器可能会发现在相互等待：一个处理器正准备更新这个值，但是另一个处理器正在做这件事，所以它不得不等待另一个处理器完成其更新并发布出来，这被称为高竞争(high contention)；如果处理期间很少相互等待，那么称为低竞争(low contention)。</p>

<p>像上面的循环，counter会在缓存间来回传递多次，这被称为“乒乓缓存”(cache ping-pong)，它会严重影响应用程序的性能。当一个处理器因为等待缓存更新而停止运行时，这个处理器就不能做任何事情，即使同时有其他可以做有用的工作的线程在等待。这无疑是整个应用程序的坏消息。也许你在想这不可能发生在你的代码里面，因为你不会有上面那样的循环，但是如果你使用mutex呢，如果你在一个循环里面接受一个mutex，那么你的代码就回跟上面的循环出现一样的问题。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="n">my_data</span> <span class="n">data</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">processing_loop_with_mutex</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">done_processing</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>如何避免“乒乓缓存”(cache ping-pong)呢？答案很好地与改善并发潜力的一般准则相联系：<strong>尽可能减少两个线程竞争同一内存位置(memory location)的潜力(do what you can to reduce the potential for two threads competing for the same memory location)</strong>。然而即使某个内存位置只能由一个线程访问，由于伪共享(false sharing)的原因，你仍然能够获得“乒乓缓存”(cache ping-pong)。</p>

<h4 id="false-sharing">False sharing</h4>

<p><strong>处理器缓存通常不会用来处理单个内存位置(memory location)，但其会用来处理称为高速缓存行(cache line)的内存块</strong>。这些内存块大小通常为32或64字节，但具体细节取决于所使用的特定处理器型号。由于高速缓存硬件仅在高速缓存行(cache line)大小的内存块中进行处理，所以相邻内存位置(memory location)中的小数据项将位于相同的高速缓存行(cache line)中。有时候这是很好的：如果线程访问的数据集在同一个cache line中，那么程序性能会比数据集分布多个cache line中要好。然而，如果cache line中的数据项是不相关的，且需要被不同线程访问，这就会导致一个主要的性能问题。</p>

<p>假设你有一个int数组和一个线程集，每个线程都访问数组中的自己的条目，但重复执行，包括更新。由于int通常比缓存行小得多，所以相当数量的条目将在同一个cache line中，所以即使每个线程只访问自己的数组条目，但仍然发生了“乒乓缓存”(cache ping-pong)：每次访问条目0的线程A需要更新值时，需要将cache line的所有权传输到运行A的处理器，当访问条目1的线程B需要更新值时，cache line的所有权又被传输到运行B的处理器。虽然没有数据是共享的，但是cache line却是共享的，这就是术语false sharing的由来。这里的解决方案是<strong>结构化数据，使得同一线程要访问的数据项在内存中相互靠近（从而更可能在同一个cache line中），而不同线程访问的数据项在内存中相互远离，因此更有可能在单独的cache line中</strong>。</p>

<h4 id="how-close-is-your-data">How close is your data?</h4>

<p>false sharing是由于一个线程访问的数据太靠近另一个线程访问的数据引起的；另一个与数据布局相关的问题是数据接近度(proximity)：如果一个线程的访问的数据在内存中散列分布，那么这些数据很可能位于不同的cache line上，反之，如果数据在内存中相互靠近，那么这些数据就更可能位于相同的cache line上。所以，<strong>如果数据散列分布，就需要将更多的cache line加载到处理器缓存上，这会增加内存的访问延迟，并且降低性能</strong>。另外，如果数据散列分布，那么cache line中就会有更大的可能包含其它线程访问的数据，极端情况下，你所需要的数据甚至比你不关心的数据要少；这将浪费宝贵的缓存空间，从而增加处理器未命中的概率。</p>

<p>如果线程数量多于内核或处理器数量，操作系统可能会选择将一个线程安排给这个内核一段时间，之后再安排给另一个内核一段时间，这就需要将cache line从一个内核上转移到另一个内核上；<strong>转移的cache line越多，耗费的时间就越多</strong>。虽然操作系统尽量避免这样的情况发生，不过当其发生的时候，就会对性能有很大的影响。</p>

<h4 id="oversubscription-and-excessive-task-switching">Oversubscription and excessive task switching</h4>

<p><strong>在多线程系统中，线程数通常比处理器数要多，除非你使用的是大型并发系统</strong>。然而线程经常花费时间等待外部I/O、或等待mutex、或等待条件变量等等，所以程序通常拥有额外的线程执行有用的工作，而不是让处理器在等待时处于空闲状态。但是当线程数太多，以致等待运行的线程数超过了可用的处理器数时，系统就会开始任务切换，这也会增加时间开销，当一个任务重复产生新线程而不受控制时，可能会出现超额认购(oversubscription)。</p>

<h3 id="designing_data_structures_for_multithreaded_performance">为多线程性能设计数据结构</h3>

<p><strong>为多线程性能设计数据结构的关键点在于：竞争(contention)、伪共享(false sharing)、数据接近度(proximity)</strong>。这三个点都能对性能造成巨大的影响，你通常可以修改数据布局、或更改为每个线程分配的数据来改善你的代码。</p>

<h4 id="dividing-array-elements-for-complex-operations">Dividing array elements for complex operations</h4>

<p>假设你需要对两个超大的矩阵进行相乘，我们知道矩阵的乘法如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>如果 AB = C，其中A、B、C都是矩阵
那么 Cij = Ai0*B0j + Ai1*B1j + Ai2*B2j + ...
</code></pre>
</div>

<p>假设这两个超大的矩阵拥有上千行、上千列，那么使用多线程可以优化该乘法。通常，非稀疏矩阵在内存中用一个大数组表示，第二行的所有元素跟随在第一行的所有元素之后，以此类推。为了做矩阵乘法，你需要三个这样的大数组，两个用于相乘，一个用于结果。</p>

<p>你可以使用多种方法来划分工作。如果你的行列数超过了可用的处理器数，那么你可以让每个线程计算一定数量的结果元素，可以是几行、几列、或者一个子矩阵，都没问题。但是我们知道，<strong>访问连续的元素会比访问分散的元素要好</strong>，因为前者会减少cache line的使用量和false sharing的概率。</p>

<p>现在假设第一个矩阵A是N行M列，第二个矩阵B是M行K列，且每行元素使用一个cache line。如果每个线程计算结果C的一行元素，那么一个线程使用的cache line数为1+M+1，其中只有对B的数据的访问是分散的，各个线程使用的A和C的cache line都是不同的；如果每个线程计算结果C的一列元素，那么一个线程使用的cache line数为N+M+N，各个线程使用的cache line都是一样的，这不仅会增加缓存的使用量，还会增加false sharing的概率；如果每个线程计算结果C的一个PxQ子矩阵元素，那么一个线程使用的cache line数为P+M+P，各个线程使用的cache line可能相同，但相对于第一种方法，可能会减少缓存的使用量。</p>

<p>考虑两个1000x1000的矩阵相乘，你有100个处理器。如果每个处理器处理结果的10行元素，那么需要访问第一个矩阵的10x1000个元素，第二个矩阵的1000x1000个元素，结果矩阵的10x1000个元素，一共需要访问1020000个元素；如果每个处理器处理结果的100x100子矩阵元素，那么需要访问第一个矩阵的100x1000个元素，第二个矩阵的1000x100个元素，结果矩阵的100x100个元素，一共需要访问210000个元素，是处理10行元素访问元素的五分之一，所以会更好的提升性能。</p>

<p><strong>将工作划分为小块可能会工作的更好，你可以根据源矩阵的大小和处理器的数量来动态的对块的大小进行调整</strong>。</p>

<p>也许你在想这个例子到底是想说什么？答案就是：<strong>很多情况下，你并不需要修改基本算法，你只需要简单的修改划分方式就能很好的提升性能了</strong>。</p>

<h4 id="data-access-patterns-in-other-data-structures">Data access patterns in other data structures</h4>

<p>从根本上来讲，当你尝试优化其它数据结构的数据访问模式时，需要考虑的与上面的数组差不多：</p>

<ul>
  <li>尝试调整数据在线程间的分布，使得同一线程使用的数据相互靠近；</li>
  <li>尝试最小化每个线程的数据量；</li>
  <li>尝试确保不同线程使用的数据相互远离，以避免false sharing。</li>
</ul>

<blockquote>
  <p>Of course, that’s not easy to apply to other data structures. For example, binary trees are inherently difficult to subdivide in any unit other than a subtree, which may or may not be useful, depending on how balanced the tree is and how many sections you need to divide it into. Also, the nature of the trees means that the nodes are likely dynamically allocated and thus end up in different places on the heap.</p>

  <p>Now, having data end up in different places on the heap isn’t a particular problem in itself, but it does mean that the processor has to keep more things in cache. This can actually be beneficial. If multiple threads need to traverse the tree, then they all need to access the tree nodes, but if the tree nodes only contain pointers to the real data held at the node, then the processor only has to load the data from memory if it’s actually needed. If the data is being modified by the threads that need it, this can avoid the performance hit of false sharing between the node data itself and the data that provides the tree structure.</p>

  <p>There’s a similar issue with data protected by a mutex. Suppose you have a simple class that contains a few data items and a mutex used to protect accesses from multiple threads. If the mutex and the data items are close together in memory, this is ideal for a thread that acquires the mutex; the data it needs may well already be in the processor cache, because it was just loaded in order to modify the mutex. But there’s also a downside: if other threads try to lock the mutex while it’s held by the first thread, they’ll need access to that memory. Mutex locks are typically implemented as a readmodify-write atomic operation on a memory location within the mutex to try to acquire the mutex, followed by a call to the operating system kernel if the mutex is already locked. This read-modify-write operation may well cause the data held in the cache by the thread that owns the mutex to be invalidated. As far as the mutex goes, this isn’t a problem; that thread isn’t going to touch the mutex until it unlocks it. However, if the mutex shares a cache line with the data being used by the thread, the thread that owns the mutex can take a performance hit because another thread tried to lock the mutex!</p>
</blockquote>

<h3 id="additional_considerations_when_designing_for_concurrency">多线程设计时的其它注意事项</h3>

<p>虽然我们已经讨论了很多并发设计需要注意的事项，但是要想开发一个好的并发代码，还需要考虑异常安全和可扩展性(scalability)。<strong>如果一段代码的性能随着内核数量的增加而增加(一般呈线性趋势，即100个内核运行该代码的性能是一个内核运行该代码的性能的100倍)，那么称该代码是可扩展的(scalable)</strong>。单线程代码一定不是可扩展的。</p>

<h4 id="section-1">并发算法中的异常安全</h4>

<p>异常安全是一个好代码必不可少的部分，并发代码也不例外，<strong>实际上并发算法比一般的序列算法更需要注意异常安全</strong>。</p>

<p>如果一个序列算法抛出异常，它只需要考虑自身资源的清理以及异常的处理，它也可以传回给调用者让调用者进行处理；但是并发算法中很多操作都是在不同线程中的，所以异常是不允许传回给调用者的，因为它们在一个错误的调用栈中。如果一个新线程中的函数异常退出，那么应用程序将会终止(terminate)。</p>

<p>查看如下代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accumulate_block</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// 注意std::accumulate第三个参数是值传递
</span>		<span class="n">result</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">init</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">results</span><span class="p">(</span><span class="n">num_threads</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
		<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span>
			<span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span>
			<span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>

	<span class="c1">// std::mem_fn生成一个包装对象的成员函数的指针，在C++14中被移除
</span>	<span class="cm">/*std::for_each(threads.begin(), threads.end(),
		std::mem_fn(&amp;std::thread::join));*/</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
	<span class="p">}</span>
	
	<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">results</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">init</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sum1</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"accumulate_block tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">sum2</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sum2</span><span class="p">);</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_accumulate tooks "</span> 
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sum1 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum1</span>
		<span class="o">&lt;&lt;</span> <span class="s">", sum2 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum2</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>accumulate_block tooks 0.260436 ms
parallel_accumulate tooks 0.851227 ms
sum1 = 5026673, sum2 = 5026673
</code></pre>
</div>

<p><strong>当你调用一个你知道的可能会发生异常的函数，或者调用了一个用户自定义的函数时，可能发生异常</strong>：</p>

<ul>
  <li>在<code class="highlighter-rouge">block_start</code>初始化之前的所有操作都是异常安全的，因为你除了初始化之外什么也没有做，而且这些操作全部都在调用线程上运行。</li>
  <li>一旦创建的线程发生了异常，由于thread的析构函数在没有调用<code class="highlighter-rouge">detach</code>或<code class="highlighter-rouge">join</code>的情况下会调用<code class="highlighter-rouge">terminate</code>，所以程序将会终止；</li>
  <li>在<code class="highlighter-rouge">accumulate_block</code>中的<code class="highlighter-rouge">std::accumulate</code>也可能抛出异常，因为没有做catch处理。</li>
</ul>

<p>在基础篇我们知道，<code class="highlighter-rouge">std::future</code>是可以存储异常的，所以我们用<code class="highlighter-rouge">std::future</code>来重构上面的代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accumulate_block</span>
<span class="p">{</span>
	<span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">init</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">futures</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">T</span> <span class="n">last_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">try</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
			<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
			<span class="c1">// !!!!!!特别注意，如果参数不加括号会被当做函数声明，你也可以使用{}来初始化
</span>			<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span>
				<span class="p">(</span><span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()));</span>
			<span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
			<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span><span class="n">block_start</span><span class="p">,</span><span class="n">block_end</span><span class="p">);</span>
			<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_result</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

		<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(...)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">throw</span><span class="p">;</span> <span class="c1">// throw之后，后面的代码将不再运行
</span>	<span class="p">}</span>

	<span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// 如果工作线程抛出异常，将在主线程的这里重新抛出
</span>		<span class="n">result</span> <span class="o">+=</span> <span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="n">last_result</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">sum1</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"accumulate_block tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">sum2</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sum2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_accumulate tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sum1 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum1</span>
		<span class="o">&lt;&lt;</span> <span class="s">", sum2 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum2</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>accumulate_block tooks 0.519273 ms
parallel_accumulate tooks 1.22682 ms
sum1 = 5026673, sum2 = 5026673
</code></pre>
</div>

<p>上面的<code class="highlighter-rouge">parallel_accumulate</code>函数的try-catch语句太丑了，而且你在正常控制语句和catch控制语句中写了重复的代码，这往往是不好的，因为如果你要修改的话就需要修改多个地方。C++ 处理这种问题的惯用方法是将重复的代码写在析构函数里：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accumulate_block</span>
<span class="p">{</span>
	<span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">init</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">futures</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">);</span>

	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
		<span class="c1">// !!!!!!特别注意，如果参数不加括号会被当做函数声明，你也可以使用{}来初始化
</span>		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">T</span><span class="p">(</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span>
			<span class="p">(</span><span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()));</span>
		<span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
		<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">),</span><span class="n">block_start</span><span class="p">,</span><span class="n">block_end</span><span class="p">);</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">T</span> <span class="n">last_result</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

	<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">threads</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">threads</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
		<span class="n">std</span><span class="o">::</span><span class="n">mem_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">join</span><span class="p">));</span>

	<span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// 如果工作线程抛出异常，将在主线程的这里重新抛出
</span>		<span class="c1">// 因为future.get()会阻塞直到其状态为ready，所以不用显式join
</span>		<span class="n">result</span> <span class="o">+=</span> <span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="n">last_result</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">sum1</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"accumulate_block tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">sum2</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sum2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_accumulate tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sum1 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum1</span>
		<span class="o">&lt;&lt;</span> <span class="s">", sum2 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum2</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>accumulate_block tooks 0.286739 ms
parallel_accumulate tooks 0.853801 ms
sum1 = 5026673, sum2 = 5026673
</code></pre>
</div>

<h4 id="stdasync">使用<code class="highlighter-rouge">std::async</code>处理异常</h4>

<p>在<a href="https://chorior.github.io/2017/04/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%AF%87/#functional_program_with_future">基础篇</a>中，我们知道<code class="highlighter-rouge">std::async</code>确保线程数不会过载，所以<code class="highlighter-rouge">std::async</code>很适合用来做并发递归：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accumulate_block</span>
<span class="p">{</span>
	<span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_chunk_size</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="n">max_chunk_size</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="n">mid_point</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

		<span class="c1">// 如果async线程发生异常，在get()时会重新抛出
</span>		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">first_half_result</span> <span class="o">=</span>
			<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">,</span>
				<span class="n">first</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">init</span><span class="p">);</span>

		<span class="c1">// 如果这里抛出异常，future的析构函数会等待其线程完成
</span>		<span class="n">T</span> <span class="n">second_half_result</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">first_half_result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">second_half_result</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">sum1</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"accumulate_block tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">sum2</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sum2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_accumulate tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sum1 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum1</span>
		<span class="o">&lt;&lt;</span> <span class="s">", sum2 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum2</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>accumulate_block tooks 0.39162 ms
parallel_accumulate tooks 39.3281 ms
sum1 = 5026673, sum2 = 5026673
</code></pre>
</div>

<h4 id="amdahl-">可扩展性和 Amdahl 定律</h4>

<p>可扩展性就是你的代码利用处理器数量改善性能的能力，单线程代码永远不能利用处理器的数量。理想情况下，每个线程每时每刻都在做有用的工作，但实际上这是不可能的，因为<strong>线程间经常花费时间相互等待或等待I/O操作完成</strong>。</p>

<p>一个简单的看待可扩展性的方法是：将程序划分为“串行”部分和“并行”部分，“串行”部分只有一个线程在做有用的工作，“并行”部分所有可用的处理器都在做有用的工作；所以如果程序运行在一个拥有较多处理器的系统上时，毫无疑问“并行”部分会完成的更加快速。假设“串行”部分占整个程序的比例为Fs，那么在带有N个处理器的系统上运行该程序的性能增益为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">P</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">Fs</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">Fs</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>
</code></pre>
</div>

<p>上面的公式就是Amdahl 定律，<strong>这个定律经常在讨论并发代码性能时被引用</strong>，由该定律可知，<strong>并发程序的性能绝对不会超过1/Fs</strong>。</p>

<p>所以<strong>减少“串行”部分的大小，或者减少线程等待的时间，就能更好的改善程序的性能</strong>。如果我们在线程等待的时候做一些有用的事情，就能将这个等待“隐藏”掉。</p>

<p>阻塞的线程相当于什么都没做，但这浪费了CPU时间。<strong>如果你知道一个线程可能花费相当长的时间等待，那么你可以通过运行一个或多个线程来利用这个时间</strong>。</p>

<p>例如，如果一个线程正在等待一个I/O操作完成，那么你可以使用异步I/O来进行这个操作，这样线程就可以执行其它有用的工作，同时后台运行着I/O操作；如果一个线程正在等待另一个线程完成一个操作，那么你可以尝试自己完成那个操作；如果一个线程正在等待一个任务被完成，但是这个任务还没有被启动，那么你可以尝试在本线程完成这个任务、或者做其它没有开始的任务，就像<a href="#data_based_work_division">上面</a>的<code class="highlighter-rouge">do_sort</code>一样。</p>

<p><strong>有时候添加线程并不是为了利用所有可用的处理器，而是为了对外部事件进行及时的响应</strong>。</p>

<h3 id="improving_responsiveness_with_concurrency">多线程改善响应能力</h3>

<p>大多数图形化用户接口框架都是事件驱动型(event driven)，其主循环很可能与下面类似：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">event_data</span> <span class="n">event</span> <span class="o">=</span> <span class="n">get_event</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">quit</span><span class="p">)</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="n">process</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>为了确保及时响应用户输入，<code class="highlighter-rouge">get_event</code>和<code class="highlighter-rouge">process</code>必须以合理的频率被调用，不管程序在做什么。在<a href="#task_type_based_work_division">基于任务类型的工作划分</a>第一节中，我们了解了要使单线程及时处理用户输入是会大大增加代码的复杂性的，通过分离关注点，我们可以将处理用户输入与任务执行放在不同的线程中，下面的示例没有考虑线程数过载，且只具有参考价值：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">task_thread</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">task_cancelled</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">gui_thread</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">event_data</span> <span class="n">event</span> <span class="o">=</span> <span class="n">get_event</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">quit</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">process</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">task</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">task_complete</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">task_cancelled</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">do_next_operation</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">task_cancelled</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">perform_cleanup</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">post_gui_event</span><span class="p">(</span><span class="n">task_complete</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="n">event_data</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
	<span class="p">{</span>
	<span class="k">case</span> <span class="n">start_task</span><span class="p">:</span>
		<span class="n">task_cancelled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">task_thread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">stop_task</span><span class="p">:</span>
		<span class="n">task_cancelled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">task_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">task_complete</span><span class="p">:</span>
		<span class="n">task_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
		<span class="n">display_results</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="c1">//...
</span>	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="std_for_each">std::for_each</h3>

<p><code class="highlighter-rouge">std::for_each</code>对范围内每个元素调用同一个函数，其并行版与序列版唯一的区别就是元素调用函数的顺序。要实现一个<code class="highlighter-rouge">std::for_each</code>的并行版本，只需要基于数据的工作划分，即每个线程做一定数量的元素的工作。</p>

<ul>
  <li>假设系统只有这一个多线程程序在运行，那么你可以使用<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>来决定线程的数量；</li>
  <li>你知道元素的数量在工作开始前就能得到，所以你可以在工作开始前就将数据划分好；</li>
  <li>你也知道每个线程肯定是相互独立的，所以你可以使用连续的数据块来避免伪共享(false sharing)。</li>
</ul>

<p>一个简单的实现如下，为了体现元素操作的顺序，借用<a href="https://chorior.github.io/2017/05/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/#linked_list">threadsafe_list</a>来保存操作的顺序：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="cp">#include "myLinkedList.h"
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parallel_for_each</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Func</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">futures</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">);</span>

	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span>
			<span class="p">[</span><span class="o">=</span><span class="p">]()</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="p">});</span>
		<span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
		<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span> <span class="c1">// task是一个可调用对象
</span>		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">51</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

	<span class="n">threadsafe_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">order</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">order</span><span class="p">](</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span> 
		<span class="n">order</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">};</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"for_each tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">order</span><span class="p">.</span><span class="n">for_each</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ends</span><span class="p">;</span> <span class="p">});</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="n">order</span><span class="p">.</span><span class="n">remove_if</span><span class="p">([](</span><span class="kt">int</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">});</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">parallel_for_each</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="n">decltype</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">func</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_for_each tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">order</span><span class="p">.</span><span class="n">for_each</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ends</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for_each tooks 0.228043 ms
50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
parallel_for_each tooks 0.829425 ms
50 33 49 32 48 31 47 30 46 29 45 28 44 27 43 26 42 25 41 24 40 23 39 22 38 21 37 20 36 19 35 18 34 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
</code></pre>
</div>

<p>再用<code class="highlighter-rouge">std::async</code>来实现一下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parallel_for_each</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">Func</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">min_per_thread</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="k">const</span> <span class="n">mid_point</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">first_half</span> <span class="o">=</span>
			<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parallel_for_each</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">Func</span><span class="o">&gt;</span><span class="p">,</span>
				<span class="n">first</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">parallel_for_each</span><span class="p">(</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="n">first_half</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for_each tooks 0.307587 ms
50 49 48 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
parallel_for_each tooks 0.643719 ms
24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 50 2 49 1 48 0 47 46 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25
</code></pre>
</div>

<h3 id="std_find">std::find</h3>

<p><code class="highlighter-rouge">std::find</code>并不一定对所有元素都做一次操作，所以如果已经找到目标，就应该中断其它线程。一种中断其它线程的方法是设置一个原子flag变量，然后在每次操作完成之后对其进行检查。为了返回值，以及传递可能发生的异常，你可以使用<code class="highlighter-rouge">std::packaged_task</code>或<code class="highlighter-rouge">std::promise</code>，两者的区别就是：<code class="highlighter-rouge">std::packaged_task</code>可以存储所有发生的异常，如果有一个线程发生了异常，其它线程还能继续执行，但是<code class="highlighter-rouge">std::promise</code>只能存储一个异常，只要有一个线程发生了异常，就会中断所有执行。</p>

<p>虽然<code class="highlighter-rouge">std::packaged_task</code>可以存储所有发生的异常，但实际上只能有一个异常能被抛出，所以我们选择<code class="highlighter-rouge">std::promise</code>来实现<code class="highlighter-rouge">std::find</code>的并行算法。这里一个比较重要的点是：如果找不到目标，那么<code class="highlighter-rouge">future.get()</code>将永远阻塞下去，所以在调用<code class="highlighter-rouge">get()</code>之前，需要等待所有线程结束，并对flag进行检查。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">MatchType</span><span class="o">&gt;</span>
<span class="n">Iterator</span> <span class="n">parallel_find</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">MatchType</span> <span class="n">match</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">find_element</span>
	<span class="p">{</span>
		<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">end</span><span class="p">,</span>
			<span class="n">MatchType</span> <span class="n">match</span><span class="p">,</span>
			<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;*</span> <span class="n">result</span><span class="p">,</span>
			<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;*</span> <span class="n">done_flag</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">try</span>
			<span class="p">{</span>
				<span class="k">for</span> <span class="p">(;</span> <span class="p">(</span><span class="n">begin</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done_flag</span><span class="o">-&gt;</span><span class="n">load</span><span class="p">();</span> <span class="o">++</span><span class="n">begin</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">begin</span> <span class="o">==</span> <span class="n">match</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="c1">// 如果有多个匹配的值，那么这里会发生竞争，
</span>						<span class="c1">// 但是没关系，不管哪个值被设置，都是正确的值
</span>						<span class="c1">// 同理，下面的异常设置
</span>						<span class="n">result</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="n">begin</span><span class="p">);</span>
						<span class="n">done_flag</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
						<span class="k">return</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">catch</span> <span class="p">(...)</span>
			<span class="p">{</span>
				<span class="n">try</span>
				<span class="p">{</span>
					<span class="n">result</span><span class="o">-&gt;</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
					<span class="n">done_flag</span><span class="o">-&gt;</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">catch</span> <span class="p">(...)</span>
				<span class="p">{</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">last</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">done_flag</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="c1">// 代码块的作用是控制join_threads的生命周期
</span>	<span class="p">{</span>
		<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">);</span>
		<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
			<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
			<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">find_element</span><span class="p">(),</span>
				<span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done_flag</span><span class="p">);</span>
			<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">find_element</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">done_flag</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_flag</span><span class="p">.</span><span class="n">load</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">last</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">goal</span> <span class="o">=</span> <span class="mi">501</span><span class="p">;</span>

	<span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span> <span class="n">result1</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span> <span class="n">result2</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">result1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">goal</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"for_each tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">result2</span> <span class="o">=</span> <span class="n">parallel_find</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="n">decltype</span><span class="p">(</span><span class="n">goal</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">goal</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_for_each tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">result1</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">result1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="n">result2</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">result2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for_each tooks 0.014433 ms
parallel_for_each tooks 0.88844 ms
501
501

</code></pre>
</div>

<p>再用<code class="highlighter-rouge">std::async</code>实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">MatchType</span><span class="o">&gt;</span>
<span class="n">Iterator</span> <span class="n">parallel_find_impl</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">MatchType</span> <span class="n">match</span><span class="p">,</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;&amp;</span> <span class="n">done</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">try</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">length</span><span class="o">&lt;</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">min_per_thread</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="p">(</span><span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">.</span><span class="n">load</span><span class="p">();</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">first</span> <span class="o">==</span> <span class="n">match</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">first</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">last</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">Iterator</span> <span class="k">const</span> <span class="n">mid_point</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="p">(</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
			<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">&gt;</span> <span class="n">async_result</span> <span class="o">=</span>
				<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parallel_find_impl</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">MatchType</span><span class="o">&gt;</span><span class="p">,</span>
					<span class="n">mid_point</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">done</span><span class="p">));</span>
			<span class="n">Iterator</span> <span class="k">const</span> <span class="n">direct_result</span> <span class="o">=</span>
				<span class="n">parallel_find_impl</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">mid_point</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">direct_result</span> <span class="o">==</span> <span class="n">mid_point</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">async_result</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">:</span> <span class="n">direct_result</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(...)</span>
	<span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">throw</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">MatchType</span><span class="o">&gt;</span>
<span class="n">Iterator</span> <span class="n">parallel_find</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">MatchType</span> <span class="n">match</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>
	<span class="c1">// 为了递归调用且有一个全局flag，所以需要另起一个函数
</span>	<span class="k">return</span> <span class="n">parallel_find_impl</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">done</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>for_each tooks 0.03047 ms
parallel_for_each tooks 3.08998 ms
501
501

</code></pre>
</div>

<h3 id="std_partial_sum">std::partial_sum</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_InIt</span><span class="p">,</span>
	<span class="k">class</span> <span class="nc">_OutIt</span><span class="p">,</span>
	<span class="k">class</span> <span class="nc">_Fn2</span><span class="o">&gt;</span> <span class="kr">inline</span>
	<span class="n">_OutIt</span> <span class="n">partial_sum</span><span class="p">(</span><span class="n">_InIt</span> <span class="n">_First</span><span class="p">,</span> <span class="n">_InIt</span> <span class="n">_Last</span><span class="p">,</span>
		<span class="n">_OutIt</span> <span class="n">_Dest</span><span class="p">,</span> <span class="n">_Fn2</span> <span class="n">_Func</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// compute partial sums into _Dest, using _Func
</span>	<span class="n">_DEPRECATE_UNCHECKED</span><span class="p">(</span><span class="n">partial_sum</span><span class="p">,</span> <span class="n">_Dest</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">_Partial_sum_no_deprecate</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Last</span><span class="p">,</span> <span class="n">_Dest</span><span class="p">,</span> <span class="n">_Func</span><span class="p">));</span>
	<span class="p">}</span>
</code></pre>
</div>

<p>查看<code class="highlighter-rouge">partial_sum</code>的<a href="http://en.cppreference.com/w/cpp/algorithm/partial_sum">官方说明文档</a>，其功能简要的概括一下就是：对范围内的每个元素进行叠加，但是每加一个元素，就保存一个值，保存的开始位置在第三个参数中给出，第四个参数可以指定其他的二元算法。</p>

<p>要想实现该算法的并行版本，由于各个线程的数据不是相互独立的，例如第一个元素在每个线程都被使用了，所以就不能像上面的<code class="highlighter-rouge">for_each</code>和<code class="highlighter-rouge">find</code>一样进行简单的划分了。假设你有一组数据{1,2,3,4,5,6,7,8,9}，你将其分为三个小块，{1,2,3}、{4,5,6}、{7,8,9}，对这三个小块分别进行<code class="highlighter-rouge">partial_sum</code>，结果将是{1,3,6}、{4,9,15}、{7,15,24}，合并结果为{1,3,6,4,9,15,7,15,24}，很明显正确结果应该是{1,3,6,10,15,21,28,36,45}，怎样才能获得正确结果呢？如果能将第一小块的最后一个结果添加到第二个小块的所有结果上，再将第二个小块的最后一个结果添加到第三个小块的左右结果上，结果就正确了。</p>

<p>如果每个小块都先更新最后一个结果，那么计算每个小块剩余元素的线程就可以与下一个小块线程同时运行了。但是如果你的总元素个数太少或者处理器数量太多的话，后面的处理器肯定需要等待前面的处理器返回结果才能开始运行，这是不好的。换一种传递方式，你首先将相邻元素求和，结果为{1,3,5,7,9,11,13,15,17}，这个结果对于两个元素是完全正确的；然后将这些结果两个两个相加，结果为{1,3,6,10,14,15,22,26,30}，这个结果对于前四个元素也是完全正确的；在将结果四个四个相加，结果为{1,3,6,10,15,18,28,36,44}，该结果对于前八个元素是完全正确的；接着是{1,3,6,10,15,18,28,36,45}，该结果就是最终结果。</p>

<p>如果一共有N个元素、k个线程，那么使用第一种方法，每个线程需要做一次计算最后一个结果的操作，次数为N/k，然后再做一次值的传递操作，次数也是N/k；使用第二种方法需要做log2(N)次N个操作，所以第一种方法的复杂度是O(N)，第二种方法的复杂度是Nlog2(N)，然而如果你有N个处理器，那么第二种方法会使得每个处理器只有log2(N)个操作，而第一种方法在K变得足够大时，会序列化绝大多数操作。</p>

<p>下面实现了第一种算法：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parallel_partial_sum</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">typedef</span> <span class="k">typename</span> <span class="n">Iterator</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_chunk</span>
	<span class="p">{</span>
		<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span>
			<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;*</span> <span class="n">previous_end_value</span><span class="p">,</span>
			<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;*</span> <span class="n">end_value</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">try</span>
			<span class="p">{</span>
				<span class="n">Iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
				<span class="o">++</span><span class="n">end</span><span class="p">;</span>
				<span class="n">std</span><span class="o">::</span><span class="n">partial_sum</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">begin</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">previous_end_value</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">value_type</span> <span class="n">addend</span> <span class="o">=</span> <span class="n">previous_end_value</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">();</span>
					<span class="o">*</span><span class="n">last</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">end_value</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">end_value</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> 
						<span class="p">[</span><span class="n">addend</span><span class="p">](</span><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">item</span> <span class="o">+=</span> <span class="n">addend</span><span class="p">;</span>
					<span class="p">});</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">end_value</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">end_value</span><span class="o">-&gt;</span><span class="n">set_value</span><span class="p">(</span><span class="o">*</span><span class="n">last</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">catch</span> <span class="p">(...)</span>
			<span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">end_value</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">end_value</span><span class="o">-&gt;</span><span class="n">set_exception</span><span class="p">(</span>
						<span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
				<span class="p">}</span>
				<span class="k">else</span>
				<span class="p">{</span>
					<span class="k">throw</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">min_per_thread</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">max_threads</span> <span class="o">=</span>
		<span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">min_per_thread</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">min_per_thread</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hardware_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_threads</span> <span class="o">=</span>
		<span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">hardware_threads</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">hardware_threads</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span> <span class="n">max_threads</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="n">num_threads</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">end_values</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">previous_end_values</span><span class="p">;</span>

	<span class="c1">// 分配至少能容纳num_threads - 1个元素的内存空间
</span>	<span class="c1">// 可以避免在push_back时重新分配内存，因为你知道需要多大的空间
</span>	<span class="n">previous_end_values</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">);</span>
	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="n">block_last</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_last</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">process_chunk</span><span class="p">(),</span>
			<span class="n">block_start</span><span class="p">,</span> <span class="n">block_last</span><span class="p">,</span>
			<span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">previous_end_values</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">end_values</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_last</span><span class="p">;</span>
		<span class="o">++</span><span class="n">block_start</span><span class="p">;</span>
		<span class="n">previous_end_values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">end_values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_future</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="n">Iterator</span> <span class="n">final_element</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">final_element</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">process_chunk</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">final_element</span><span class="p">,</span>
		<span class="p">(</span><span class="n">num_threads</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">previous_end_values</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">51</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">partial_sum</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"partial_sum tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">parallel_partial_sum</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_partial_sum tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>partial_sum tooks 0.027584 ms
parallel_partial_sum tooks 0.886516 ms
0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 378 406 
435 465 496 528 561 595 630 666 703 741 780 820 861 903 946 990 1035 1081 1128 1176 1225 1275
0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 378 406 
435 465 496 528 561 595 630 666 703 741 780 820 861 903 946 990 1035 1081 1128 1176 1225 1275
</code></pre>
</div>

<p>在对<code class="highlighter-rouge">previous_end_values</code>进行操作的时候，使用<code class="highlighter-rouge">push_back</code>而非以往的赋值操作，是为了让代码更加清晰，更容易理解，当然你也可以写成下面这样：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">previous_end_values</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="c1">// previous_end_values.reserve(num_threads - 1);
</span><span class="p">...</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
	<span class="n">previous_end_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">end_values</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get_future</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>在做最后一块时，也可以简化为：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">process_chunk</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">(</span><span class="n">num_threads</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">previous_end_values</span><span class="p">.</span><span class="n">back</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
		<span class="mi">0</span><span class="p">);</span>
</code></pre>
</div>

<p>第二种方法的实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">barrier</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">spaces</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">generation</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">barrier</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">count_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">count</span><span class="p">(</span><span class="n">count_</span><span class="p">),</span> <span class="n">spaces</span><span class="p">(</span><span class="n">count_</span><span class="p">),</span> <span class="n">generation</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="kt">void</span> <span class="n">wait</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">my_generation</span> <span class="o">=</span> <span class="n">generation</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">spaces</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">spaces</span> <span class="o">=</span> <span class="n">count</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
			<span class="o">++</span><span class="n">generation</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">generation</span> <span class="o">==</span> <span class="n">my_generation</span><span class="p">)</span>
				<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">done_waiting</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="o">--</span><span class="n">count</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!--</span><span class="n">spaces</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">spaces</span> <span class="o">=</span> <span class="n">count</span><span class="p">.</span><span class="n">load</span><span class="p">();</span>
			<span class="o">++</span><span class="n">generation</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">parallel_partial_sum</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">typedef</span> <span class="k">typename</span> <span class="n">Iterator</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">process_element</span>
	<span class="p">{</span>
		<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span>
			<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;&amp;</span> <span class="n">buffer</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="n">i</span><span class="p">,</span> <span class="n">barrier</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">value_type</span><span class="o">&amp;</span> <span class="n">ith_element</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">bool</span> <span class="n">update_source</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stride</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
				<span class="n">stride</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> 
				<span class="o">++</span><span class="n">step</span><span class="p">,</span> <span class="n">stride</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">source</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="n">ith_element</span><span class="p">;</span>
				<span class="n">value_type</span><span class="o">&amp;</span> <span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">ith_element</span> <span class="o">:</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="n">value_type</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">addend</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span>
					<span class="n">buffer</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">stride</span><span class="p">]</span> <span class="o">:</span> <span class="o">*</span><span class="p">(</span><span class="n">first</span> <span class="o">+</span> <span class="n">i</span> <span class="o">-</span> <span class="n">stride</span><span class="p">);</span>
				<span class="n">dest</span> <span class="o">=</span> <span class="n">source</span> <span class="o">+</span> <span class="n">addend</span><span class="p">;</span>
				<span class="n">update_source</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">step</span> <span class="o">%</span> <span class="mi">2</span><span class="p">);</span>
				<span class="n">b</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">update_source</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">ith_element</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">b</span><span class="p">.</span><span class="n">done_waiting</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">value_type</span><span class="o">&gt;</span> <span class="n">buffer</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="n">barrier</span> <span class="n">b</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">);</span>
	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">process_element</span><span class="p">(),</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span>
			<span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">process_element</span><span class="p">()(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">51</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">partial_sum</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"partial_sum tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">parallel_partial_sum</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_partial_sum tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">:</span> <span class="n">result</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>partial_sum tooks 0.041375 ms
parallel_partial_sum tooks 13.122 ms
0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 378 406 
435 465 496 528 561 595 630 666 703 741 780 820 861 903 946 990 1035 1081 1128 1176 1225 1275
0 1 3 6 10 15 21 28 36 45 55 65 78 91 105 120 136 153 171 190 210 231 253 276 300 325 351 377 406 
435 465 496 528 561 595 629 666 703 741 780 820 860 900 940 980 1020 1060 1100 1176 1225 1275
</code></pre>
</div>

<h2 id="advanced_thread_management">高级线程管理</h2>

<h3 id="thread_pool">线程池(thread pool)</h3>

<p>如果你是一个程序员，那么你大部分时间会待在办公室里，但是有时候你必须外出解决一些问题，如果外出的地方很远，就会需要一辆车，公司是不可能为你专门配一辆车的，但是大多数公司都配备了一些公用的车辆。你外出的时候预订一辆，回来的时候归还一辆；如果某一天公用车辆用完了，那么你只能等待同事归还之后才能使用。</p>

<p>线程池(thread pool)与上面的公用车辆类似：在大多数情况下，为每个任务都开一个线程是不切实际的(因为线程数太多以致过载后，任务切换会大大降低系统处理的速度)，线程池可以使得一定数量的任务并发执行，没有执行的任务将被挂在一个队列里面，一旦某个任务执行完毕，就从队列里面取一个任务继续执行。</p>

<p>线程池三个关键的问题是：</p>

<ul>
  <li>可使用的线程数；</li>
  <li>最高效的任务分配方式；</li>
  <li>是否需要等待一个任务完成。</li>
</ul>

<h4 id="section-2">最简单的线程池</h4>

<p>一个最简单的线程池拥有固定数量的线程数，这个线程数一般是<code class="highlighter-rouge">std::thread::hardware_concurrency()</code>，当你有任务要做时，你只需要将其添加到等待队列里即可，线程池会自动的从这个队列里面不断的取任务并执行。</p>

<p>下面展示了一个简单的线程池的实现，其中<code class="highlighter-rouge">threadsafe_queue</code>和<code class="highlighter-rouge">threadsafe_list</code>你可以在<a href="https://chorior.github.io/2017/05/24/C++-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1-%E4%B8%80/">C++ 多线程设计（一）</a>中找到：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
</span>
<span class="cp">#include "myQueue.h"
#include "myLinkedList.h"
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">thread</span><span class="n">_pool</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">task</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">thread_pool</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">thread_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">thread_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
					<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_pool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(...)</span>
		<span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">thread_pool</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="kt">void</span> <span class="n">submit</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">work_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">thread_pool</span> <span class="n">pool</span><span class="p">;</span>

	<span class="n">threadsafe_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">l</span><span class="p">]</span>
	<span class="p">{</span>
		<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
		<span class="cm">/*
		#ifndef _ATOMIC_IS_ADDRESS_TYPE
			operator _ITYPE() const volatile _NOEXCEPT;
			operator _ITYPE() const _NOEXCEPT;
		#endif
		*/</span>
		<span class="n">l</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="o">++</span><span class="n">i</span><span class="p">);</span>
	<span class="p">};</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">l</span><span class="p">.</span><span class="n">for_each</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="p">});</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>999 998 997 996 995 994 993 992 991 990 989 988 987 986 985 984 983 982 981 980
979 978 977 976 975 974 973 972 971 970 969 968 967 966 965 964 963 962 961 960
959 958 957 956 955 954 953 952 951 950 949 948 947 946 945 944 943 942 941 940
939 938 937 936 935 934 933 932 931 930 929 928 927 926 925 924 923 922 921 920
919 918 917 916 915 914 913 912 911 910 909 908 907 906 905 904 903 902 901 900
899 898 897 896 895 894 893 892 891 890 889 888 887 886 885 884 883 882 881 880
879 878 877 876 875 874 873 872 871 870 869 868 867 866 865 864 863 862 861 860
859 858 857 856 853 855 854 852 851 850 849 848 847 846 845 844 843 842 841 840
839 838 837 836 835 834 833 832 831 830 829 826 828 827 825 824 823 822 821 820
819 818 817 816 815 814 813 812 811 810 809 808 807 806 805 804 803 802 801 800
799 798 797 796 795 794 793 792 791 790 789 788 787 786 785 784 783 782 781 780
779 778 777 776 775 774 773 772 771 770 769 768 767 766 765 764 763 762 761 760
759 758 757 756 755 754 753 752 751 750 749 748 747 746 745 744 743 742 741 740
739 738 737 736 735 734 733 732 731 730 729 728 727 726 725 724 723 722 721 720
719 718 717 716 715 714 713 712 711 710 709 708 707 706 705 704 703 702 701 700
699 698 697 696 695 694 693 692 691 690 689 688 687 686 685 684 683 682 681 680
679 678 677 676 675 674 673 672 671 670 669 668 667 666 665 664 663 662 661 660
659 658 657 656 655 654 653 652 651 650 649 648 647 646 645 644 643 642 641 640
639 638 637 636 635 634 633 632 631 630 629 628 627 626 625 624 623 622 621 620
619 618 617 616 615 614 613 612 611 610 609 608 607 606 605 604 603 602 601 600
599 598 597 596 595 594 593 592 591 590 589 588 587 586 585 584 583 582 581 580
579 578 577 576 575 574 573 572 571 570 569 568 567 566 565 564 563 562 561 560
559 558 557 556 555 554 553 552 551 550 549 548 547 546 545 544 543 542 541 540
539 538 537 536 535 534 533 532 531 530 529 528 527 526 525 524 523 522 521 520
519 518 517 516 515 514 513 512 511 510 509 508 507 506 505 504 503 502 501 500
499 498 497 496 495 494 493 492 491 490 489 488 487 486 485 484 483 482 481 480
479 478 477 476 475 474 473 472 471 470 469 468 467 466 465 464 463 462 461 460
459 458 457 456 455 454 453 452 451 450 449 448 447 446 445 444 443 442 441 440
439 438 437 436 435 434 433 432 431 430 429 428 427 426 425 424 423 422 421 420
419 418 417 416 415 414 413 412 411 410 409 408 407 406 405 404 403 402 401 400
399 398 397 396 395 394 393 392 391 390 389 388 387 386 385 384 383 382 381 380
379 378 377 376 375 374 373 372 371 370 369 368 367 366 365 364 363 362 361 360
359 358 357 356 355 354 353 352 351 350 349 348 347 346 345 344 343 342 341 340
339 338 337 336 335 334 333 332 331 330 329 328 327 326 325 324 323 322 321 320
319 318 317 316 315 314 313 312 311 310 309 308 307 306 305 304 303 302 301 300
299 298 297 296 295 294 293 292 291 290 289 288 287 286 285 284 283 282 281 280
279 278 277 276 275 274 273 272 271 270 269 268 267 266 265 264 263 262 261 260
259 258 257 256 255 254 253 252 251 250 249 248 247 246 245 244 243 242 241 240
239 238 237 236 235 234 233 232 231 230 229 228 227 226 225 224 223 222 221 220
219 218 217 216 215 214 213 212 211 210 209 208 207 206 205 204 203 202 201 200
199 198 197 196 195 194 193 192 191 190 189 188 187 186 185 184 183 182 178 181
180 179 176 177 175 174 173 172 171 170 169 168 167 166 165 164 163 162 161 160
158 159 157 156 155 154 153 152 151 150 149 148 147 146 145 144 143 142 141 140
139 138 137 136 135 134 133 132 131 130 129 128 127 126 125 124 123 122 121 120
119 118 117 116 115 114 113 112 111 110 109 108 107 106 105 104 103 102 101 100
99 98 97 96 95 94 93 92 91 90 89 88 87 86 85 84 83 82 81 80 79 78 77 76 75 74 73
 72 71 70 69 68 67 66 65 64 63 62 61 60 59 58 57 56 55 54 53 52 51 50 49 48 47 4
6 45 44 43 42 41 40 39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20
19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
</code></pre>
</div>

<p>从结果来看，178,176,177错位表示是并发执行的。使用<code class="highlighter-rouge">std::function</code>是为了使所有的<a href="https://chorior.github.io/2017/04/04/C++-%E9%87%8A%E7%96%91-%E4%B8%89/#callable_object">可调用对象</a>都能进入线程池，<strong>示例中应该在主函数里做try-catch处理</strong>。注意成员声明的顺序，这样在销毁的时候，先等待所有线程结束，然后销毁thread vector，最后再销毁<code class="highlighter-rouge">threadsafe_queue</code>，<strong>你不能修改为其它的声明顺序</strong>。</p>

<h4 id="section-3">等待任务提交到线程池</h4>

<p>上面的线程池不能返回值，要想返回值，就需要<code class="highlighter-rouge">std::future</code>来存储值，假设使用<code class="highlighter-rouge">std::packaged_task</code>来执行任务，由于<code class="highlighter-rouge">std::packaged_task</code>是可移动不可复制的，之前的队列元素类型<code class="highlighter-rouge">std::fuction</code>需要可调用对象是可复制的，所以就需要一个能处理可移动的可调用对象封装类，完整的代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
</span>
<span class="cp">#include "myQueue.h"
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">function</span><span class="n">_wrapper</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">impl_base</span> <span class="p">{</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">call</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="o">~</span><span class="n">impl_base</span><span class="p">()</span> <span class="p">{}</span>
	<span class="p">};</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
	<span class="k">struct</span> <span class="n">impl_type</span> <span class="o">:</span> <span class="n">impl_base</span>
	<span class="p">{</span>
		<span class="n">F</span> <span class="n">f</span><span class="p">;</span>
		<span class="n">impl_type</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f_</span><span class="p">)</span> <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f_</span><span class="p">))</span> <span class="p">{}</span>
		<span class="kt">void</span> <span class="n">call</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>
	<span class="p">};</span>

	<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">impl_base</span><span class="o">&gt;</span> <span class="n">impl</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">function_wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
	<span class="n">function_wrapper</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">impl</span><span class="p">(</span><span class="k">new</span> <span class="n">impl_type</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
	<span class="p">{}</span>

	<span class="n">function_wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">function_wrapper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">function_wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">function_wrapper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="n">function_wrapper</span><span class="p">(</span><span class="n">function_wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">impl</span><span class="p">))</span>
	<span class="p">{}</span>

	<span class="n">function_wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">function_wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">impl</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">impl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span> <span class="p">{</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">thread</span><span class="n">_pool</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">function_wrapper</span> <span class="n">task</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="n">task</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">thread_pool</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">thread_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">thread_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
					<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_pool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(...)</span>
		<span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">thread_pool</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// std::result_of: 在编译的时候推导出一个函数调用表达式的返回值类型
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
		<span class="n">submit</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span>
			<span class="n">result_type</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">result_type</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
		<span class="n">work_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">thread_pool</span> <span class="n">pool</span><span class="p">;</span>

		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">;</span>
		<span class="k">auto</span> <span class="n">func</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">int</span>
		<span class="p">{</span>
			<span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">++</span><span class="n">i</span><span class="p">;</span>
		<span class="p">};</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">l</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">l</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56
57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83
84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107
108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147
148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167
168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187
188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207
208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227
228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247
248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267
268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287
288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307
308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327
328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347
348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367
368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387
388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407
408 409 410 411 412 414 413 415 416 417 418 419 420 421 422 423 424 425 426 427
428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447
448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467
468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487
488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507
508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527
528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547
548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567
568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587
588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607
608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627
628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647
648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667
668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687
688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707
708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727
728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747
748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767
768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787
788 795 789 790 791 792 793 794 796 797 798 799 800 801 802 803 804 805 806 807
808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827
828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847
848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867
868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887
888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907
908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927
928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947
948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967
968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987
988 989 990 991 992 993 994 995 996 997 998 999 1000
</code></pre>
</div>

<p>795指示是并发执行的。用该线程池去做<code class="highlighter-rouge">parallel_accumulate</code>的话，你再也不用担心线程的数量，你只需要控制块的大小；你也不用担心thread的释放，这些都由线程池为你做了；你只需要将任务提交到线程池即可：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
</span>
<span class="cp">#include "thread_pool.h"
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">accumulate_block</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">Iterator</span> <span class="n">first</span><span class="p">;</span>
	<span class="n">Iterator</span> <span class="n">last</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">accumulate_block</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">accumulate_block</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first_</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">first</span><span class="p">(</span><span class="n">first_</span><span class="p">),</span> <span class="n">last</span><span class="p">(</span><span class="n">last_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="n">T</span> <span class="k">operator</span><span class="p">()()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="k">operator</span><span class="p">()(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">T</span> <span class="k">operator</span><span class="p">()(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Iterator</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">parallel_accumulate</span><span class="p">(</span><span class="n">Iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">Iterator</span> <span class="n">last</span><span class="p">,</span> <span class="n">T</span> <span class="n">init</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">length</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">length</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">init</span><span class="p">;</span>

	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">block_size</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">num_blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span> <span class="o">+</span> <span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">block_size</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">futures</span><span class="p">(</span><span class="n">num_blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">thread_pool</span> <span class="n">pool</span><span class="p">;</span>

	<span class="n">Iterator</span> <span class="n">block_start</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Iterator</span> <span class="n">block_end</span> <span class="o">=</span> <span class="n">block_start</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">block_end</span><span class="p">,</span> <span class="n">block_size</span><span class="p">);</span>
		<span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span>
			<span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">));</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">block_end</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">T</span> <span class="n">last_result</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

	<span class="n">T</span> <span class="n">result</span> <span class="o">=</span> <span class="n">init</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="p">(</span><span class="n">num_blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">result</span> <span class="o">+=</span> <span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="n">last_result</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>

	<span class="kt">int</span> <span class="n">sum1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">sum1</span> <span class="o">=</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"accumulate_block tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">sum2</span> <span class="o">=</span> <span class="n">parallel_accumulate</span><span class="o">&lt;</span><span class="n">decltype</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">sum2</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_accumulate tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sum1 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum1</span>
		<span class="o">&lt;&lt;</span> <span class="s">", sum2 = "</span> <span class="o">&lt;&lt;</span> <span class="n">sum2</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>accumulate_block tooks 0.263322 ms
parallel_accumulate tooks 8.72107 ms
sum1 = 5026673, sum2 = 5026673
</code></pre>
</div>

<p>由于<code class="highlighter-rouge">thread_pool</code>只支持提交无参数可调用对象，所以修改了一下<code class="highlighter-rouge">accumulate_block</code>，无参数的函数调用运算符重载如果使用默认的构造对象进行调用的话，可能会发生异常，但是在主函数中进行了catch。google了一下，发现这种参数问题应该使用<code class="highlighter-rouge">std::bind</code>来解决：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// use std::bind
</span><span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span>
	<span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">(),</span><span class="n">block_start</span><span class="p">,</span><span class="n">block_end</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">// use lambda
</span><span class="n">futures</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">([</span><span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">]()</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">accumulate_block</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">block_start</span><span class="p">,</span> <span class="n">block_end</span><span class="p">);</span>
<span class="p">});</span>
</code></pre>
</div>

<h4 id="section-4">等待其它任务的任务</h4>

<p>在<a href="#data_based_work_division">基于数据的工作划分</a>中，我们实现了quick-sort的一种并行版本。该版本使用一个stack来保存划分的数据块，每个线程不断划分它要排序的数据，然后将较小的数据块添加到stack，并在当前线程排序较大的数据块。这样在结果合并时就会等待较小数据块排序完成，继而耗费一个线程处于等待状态，但是线程数是有限的，一种极端情况下所有线程都处于等待状态。</p>

<p>至今为止的两个线程池都有上面的问题，线程数有限、但是所有线程都在等待任务，从而导致没有一个空闲的线程。解决这个问题的方法是：<strong>在等待时，可以处理其它未完成的任务</strong>。线程池也可以使用这种解决方案，但是需要将<code class="highlighter-rouge">work_thread</code>循环中的处理操作单独放在一个函数中，这样如果有线程在等待，那么就可以调用这个函数处理未完成的任务了。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
#include &lt;random&gt;
#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;list&gt;
</span>
<span class="cp">#include "myQueue.h"
</span>
<span class="k">class</span> <span class="nc">join</span><span class="n">_threads</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">join_threads</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&amp;</span> <span class="n">threads_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">threads</span><span class="p">(</span><span class="n">threads_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="o">~</span><span class="n">join_threads</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">threads</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">joinable</span><span class="p">())</span>
				<span class="n">threads</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">function</span><span class="n">_wrapper</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">impl_base</span> <span class="p">{</span>
		<span class="k">virtual</span> <span class="kt">void</span> <span class="n">call</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">virtual</span> <span class="o">~</span><span class="n">impl_base</span><span class="p">()</span> <span class="p">{}</span>
	<span class="p">};</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
	<span class="k">struct</span> <span class="n">impl_type</span> <span class="o">:</span> <span class="n">impl_base</span>
	<span class="p">{</span>
		<span class="n">F</span> <span class="n">f</span><span class="p">;</span>
		<span class="n">impl_type</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f_</span><span class="p">)</span> <span class="o">:</span> <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f_</span><span class="p">))</span> <span class="p">{}</span>
		<span class="kt">void</span> <span class="n">call</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">}</span>
	<span class="p">};</span>

	<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">impl_base</span><span class="o">&gt;</span> <span class="n">impl</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">function_wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="o">&gt;</span>
	<span class="n">function_wrapper</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">impl</span><span class="p">(</span><span class="k">new</span> <span class="n">impl_type</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
	<span class="p">{}</span>

	<span class="n">function_wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">function_wrapper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">function_wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">function_wrapper</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="n">function_wrapper</span><span class="p">(</span><span class="n">function_wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">impl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">impl</span><span class="p">))</span>
	<span class="p">{}</span>

	<span class="n">function_wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">function_wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">impl</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">impl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span> <span class="p">{</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">call</span><span class="p">();</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">thread</span><span class="n">_pool</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span> <span class="n">work_queue</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">run_pending_task</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">thread_pool</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">thread_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">thread_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
					<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_pool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(...)</span>
		<span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">thread_pool</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// std::result_of: 在编译的时候推导出一个函数调用表达式的返回值类型
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
		<span class="n">submit</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span>
			<span class="n">result_type</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">result_type</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
		<span class="n">work_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">run_pending_task</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">function_wrapper</span> <span class="n">task</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">task</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">sorter</span>
<span class="p">{</span>
	<span class="n">thread_pool</span> <span class="n">pool</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">do_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">chunk_data</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">chunk_data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">chunk_data</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
		<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">chunk_data</span><span class="p">,</span> <span class="n">chunk_data</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
		<span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">partition_val</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

		<span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">divide_point</span> <span class="o">=</span>
			<span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">chunk_data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">chunk_data</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">val</span><span class="o">&lt;</span><span class="n">partition_val</span><span class="p">;</span> <span class="p">});</span>

		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">new_lower_chunk</span><span class="p">;</span>
		<span class="n">new_lower_chunk</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">new_lower_chunk</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="n">chunk_data</span><span class="p">,</span> <span class="n">chunk_data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
			<span class="n">divide_point</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">new_lower</span> <span class="o">=</span>
			<span class="n">pool</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sorter</span><span class="o">::</span><span class="n">do_sort</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span>
				<span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">new_lower_chunk</span><span class="p">)));</span>

		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">new_higher</span><span class="p">(</span><span class="n">do_sort</span><span class="p">(</span><span class="n">chunk_data</span><span class="p">));</span>
		<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">new_higher</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">new_lower</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">!=</span>
			<span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">pool</span><span class="p">.</span><span class="n">run_pending_task</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_lower</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sorter</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">do_sort</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="c1">// l.splice(iterator pos,list&amp; x, iterator i)
</span>	<span class="c1">// 将x中i指向的元素移动插入到l中pos指向的位置之前
</span>	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
	<span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pivot</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

	<span class="c1">// std::partition(iterator beg, iterator end, func)
</span>	<span class="c1">// 将[beg,end)中的元素按func分为两组，第一组使func返回true，第二组使func返回false
</span>	<span class="c1">// 返回分组后指向第二组的第一个元素的迭代器，不保证原有元素的顺序
</span>	<span class="k">auto</span> <span class="n">divide_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
		<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">pivot</span><span class="p">;</span> <span class="p">});</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lower_part</span><span class="p">;</span>
	<span class="c1">// l.splice(iterator pos,list&amp; x, iterator beg, iterator end)
</span>	<span class="c1">// 将x中[beg,end)范围内元素移动插入到l中pos指向的位置之前
</span>	<span class="n">lower_part</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lower_part</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">divide_point</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">new_lower</span><span class="p">(</span>
		<span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lower_part</span><span class="p">)));</span>
	<span class="k">auto</span> <span class="n">new_higher</span><span class="p">(</span>
		<span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">input</span><span class="p">)));</span>

	<span class="c1">// l.splice(iterator pos,list&amp; x)
</span>	<span class="c1">// 将x中所有元素移动插入到l中pos指向的位置之前
</span>	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">new_higher</span><span class="p">);</span>
	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_lower</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 随机数生成
</span>	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">u</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">default_random_engine</span> <span class="n">e</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nums</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result1</span><span class="p">,</span> <span class="n">result2</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">result1</span> <span class="o">=</span> <span class="n">sequential_quick_sort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sequential_quick_sort tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">result2</span> <span class="o">=</span> <span class="n">parallel_quick_sort</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nums</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_quick_sort tooks "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span><span class="o">-</span><span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="cm">/*for (auto &amp;i : result1)
	{
		std::cout &lt;&lt; i &lt;&lt; " ";
	}
	std::cout &lt;&lt; "\n";
	for (auto &amp;i : result2)
	{
		std::cout &lt;&lt; i &lt;&lt; " ";
	}*/</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sequential_quick_sort tooks 72.3024 ms
parallel_quick_sort tooks 61.8166 ms
</code></pre>
</div>

<p>这比<a href="#data_based_work_division">基于数据的工作划分</a>中的代码简单多了，但是<strong>由于<code class="highlighter-rouge">submit</code>或<code class="highlighter-rouge">run_pending_task</code>的每次调用都会去修改同一个<code class="highlighter-rouge">work_queue</code>，这就会造成强烈的数据竞争，虽然这个queue是线程安全的，但是还是会对性能造成很大的影响</strong>。</p>

<h4 id="workqueue">避免<code class="highlighter-rouge">work_queue</code>的竞争</h4>

<p>要想避免<code class="highlighter-rouge">work_queue</code>的竞争，可以为每个线程设立一个独立的queue，这就需要<code class="highlighter-rouge">thread_local</code>声明了，该修饰符修饰的变量具有线程生命周期：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">thread</span><span class="n">_pool</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
	<span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span> <span class="n">pool_work_queue</span><span class="p">;</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">local_work_queue</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">local_queue_type</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">run_pending_task</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span> <span class="n">local_queue_type</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">thread_local</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">local_queue_type</span><span class="o">&gt;</span>
		<span class="n">local_work_queue</span><span class="p">;</span> <span class="c1">// 静态非常量成员必须在类外进行初始化
</span>
	<span class="n">thread_pool</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">thread_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">thread_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
					<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_pool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(...)</span>
		<span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">thread_pool</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
		<span class="n">submit</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">result_type</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">result_type</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_work_queue</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">local_work_queue</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">pool_work_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">run_pending_task</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">function_wrapper</span> <span class="n">task</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_work_queue</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">local_work_queue</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">task</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">local_work_queue</span><span class="o">-&gt;</span><span class="n">front</span><span class="p">());</span>
			<span class="n">local_work_queue</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">task</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pool_work_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="n">task</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="n">thread_local</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">thread_pool</span><span class="o">::</span><span class="n">local_queue_type</span><span class="o">&gt;</span> 
<span class="n">thread_pool</span><span class="o">::</span><span class="n">local_work_queue</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
</code></pre>
</div>

<p>该实现确实避免了对<code class="highlighter-rouge">work_queue</code>的竞争，但是如果分配不均的话，一些线程可能有大量的任务，而另一些线程却无所事事。解决这个问题的方法就是：<strong>当本线程和全局queue没有任务可做时，允许获取其它线程的任务</strong>。</p>

<h4 id="section-5">线程间获取任务</h4>

<p>要想使得线程间可以相互获取任务，那么线程所持有的queue一定要能在<code class="highlighter-rouge">run_pending_task</code>被访问，同时你也必须保证这个queue被正确的同步与保护着。为此，我们可以直接使用已创建的<code class="highlighter-rouge">threadsafe_queue</code>，然后将所有线程的queue保存在一个全局容器里，<code class="highlighter-rouge">run_pending_task</code>在获取任务时，先检查本地queue，再检查全局queue，最后逐个检查其他线程的queue。这里在检查其它线程queue时，一个比较重要点是：不要从线程0到最后一个线程逐个检查，这样每个空闲的线程都会尝试从线程0的queue获取任务，可能会造成对线程0的queue的竞争访问。解决方案是：从空闲线程的下一个线程的queue开始获取，直到对所有线程的queue都做一个遍历。<strong>因为要做遍历，所以在检查其它线程的queue之前，先要判断是否所有线程都开起来了</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">thread</span><span class="n">_pool</span>
<span class="p">{</span>
	<span class="k">typedef</span> <span class="n">function_wrapper</span> <span class="n">task_type</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic_bool</span> <span class="n">done</span><span class="p">;</span>
	<span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">task_type</span><span class="o">&gt;</span> <span class="n">pool_work_queue</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">queues</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">threads</span><span class="p">;</span>
	<span class="n">join_threads</span> <span class="n">joiner</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">thread_count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">::</span><span class="n">hardware_concurrency</span><span class="p">();</span>

	<span class="c1">// 静态非常量成员必须在类外进行初始化
</span>	<span class="k">static</span> <span class="n">thread_local</span> <span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;*</span> <span class="n">local_work_queue</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">thread_local</span> <span class="kt">unsigned</span> <span class="n">my_index</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">worker_thread</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">my_index_</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">my_index</span> <span class="o">=</span> <span class="n">my_index_</span><span class="p">;</span>
		<span class="n">local_work_queue</span> <span class="o">=</span> <span class="n">queues</span><span class="p">[</span><span class="n">my_index</span><span class="p">].</span><span class="n">get</span><span class="p">();</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">run_pending_task</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="nf">pop_task_from_local_queue</span><span class="p">(</span><span class="n">task_type</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">local_work_queue</span> <span class="o">&amp;&amp;</span> <span class="n">local_work_queue</span><span class="o">-&gt;</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="nf">pop_task_from_pool_queue</span><span class="p">(</span><span class="n">task_type</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">pool_work_queue</span><span class="p">.</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="nf">pop_task_from_other_thread_queue</span><span class="p">(</span><span class="n">task_type</span><span class="o">&amp;</span> <span class="n">task</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queues</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 避免每个线程都从第一个线程获取任务
</span>			<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">index</span> <span class="o">=</span> <span class="p">(</span><span class="n">my_index</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">queues</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">my_index</span> <span class="o">&amp;&amp;</span> <span class="n">queues</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">try_pop</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
			<span class="p">{</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">thread_pool</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">done</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span> <span class="n">joiner</span><span class="p">(</span><span class="n">threads</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">thread_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">queues</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
					<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span>
						<span class="k">new</span> <span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;</span><span class="p">));</span>
				<span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
					<span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_pool</span><span class="o">::</span><span class="n">worker_thread</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(...)</span>
		<span class="p">{</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">throw</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">thread_pool</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span> <span class="n">submit</span><span class="p">(</span>
		<span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">typedef</span> <span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">result_of</span><span class="o">&lt;</span><span class="n">FunctionType</span><span class="p">()</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">result_type</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">result_type</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">result_type</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local_work_queue</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">local_work_queue</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">pool_work_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">run_pending_task</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">task_type</span> <span class="n">task</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pop_task_from_local_queue</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">pop_task_from_pool_queue</span><span class="p">(</span><span class="n">task</span><span class="p">)</span> <span class="o">||</span>
			<span class="p">((</span><span class="n">queues</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">thread_count</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
			<span class="n">pop_task_from_other_thread_queue</span><span class="p">(</span><span class="n">task</span><span class="p">)))</span>
		<span class="p">{</span>
			<span class="n">task</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">else</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">yield</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="n">thread_local</span> <span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="n">function_wrapper</span><span class="o">&gt;*</span> <span class="n">thread_pool</span><span class="o">::</span><span class="n">local_work_queue</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="n">thread_local</span> <span class="kt">unsigned</span> <span class="n">thread_pool</span><span class="o">::</span><span class="n">my_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre>
</div>

<p>虽然在<code class="highlighter-rouge">pop_task_from_other_thread_queue</code>的guard是<code class="highlighter-rouge">queues.size()</code>，但是如果不在<code class="highlighter-rouge">run_pending_task</code>中判断<code class="highlighter-rouge">queues.size() == thread_count</code>的话，就会发生异常。<strong>这个线程池对于很多场景都能很好的工作</strong>，一个不好的地方就是：<strong>不能动态改变线程的数量</strong>。</p>

<h3 id="interrupting_threads">线程中断</h3>

<p>如果一个线程运行的时间特别长、或者用户操作失误、或者其它什么原因，你都需要从一个线程中发出信号来通知另一个线程停止运行，我们称之为线程中断。</p>

<h4 id="section-6">线程的启动与中断</h4>

<p>由于C++标准库并没有提供线程中断的工具，所以我们需要自己构建一个。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">interruptible</span><span class="kr">_thread</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">interruptible_thread</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">);</span>

	<span class="kt">void</span> <span class="n">join</span><span class="p">();</span>
	<span class="kt">void</span> <span class="n">detach</span><span class="p">();</span>
	<span class="n">bool</span> <span class="n">joinable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">interrupt</span><span class="p">();</span>
<span class="p">};</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">interruptible_thread</code>类只是比<code class="highlighter-rouge">std::thread</code>类多了一个<code class="highlighter-rouge">interrupt</code>接口。你可以就使用<code class="highlighter-rouge">std::thread</code>来管理线程，并自定义一些数据结构来处理中断；但是如果从线程的角度来看的话，就会需要一个中断点，为了不传递其它额外的数据，我们定义一个无参函数<code class="highlighter-rouge">interruption_point()</code>，该函数可以通过线程启动时设置的<code class="highlighter-rouge">thread_local</code>标志的状态选择性的制造一个中断点。</p>

<p>由于这个<code class="highlighter-rouge">thread_local</code>标志必须以<code class="highlighter-rouge">interruptible_thread</code>实例可以访问的方式进行分配，所以你不能直接使用<code class="highlighter-rouge">std::thread</code>来管理中断线程，但是你可以把这个<code class="highlighter-rouge">thread_local</code>标志包装到线程函数中：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">interrupt</span><span class="n">_flag</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="kt">void</span> <span class="n">set</span><span class="p">();</span>
	<span class="n">bool</span> <span class="n">is_set</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">thread_local</span> <span class="n">interrupt_flag</span> <span class="n">this_thread_interrupt_flag</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">interruptible</span><span class="kr">_thread</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">internal_thread</span><span class="p">;</span>
	<span class="n">interrupt_flag</span><span class="o">*</span> <span class="n">flag</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">interruptible_thread</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">interrupt_flag</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">internal_thread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_thread_interrupt_flag</span><span class="p">);</span>
			<span class="n">f</span><span class="p">();</span>
		<span class="p">});</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">interrupt</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">flag</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">interruptible_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">internal_thread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">internal_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">this_thread_interrupt_flag</code>是<code class="highlighter-rouge">thread_local</code>修饰的，所以每个线程都有一个独立的实例，flag指向的地址也是不同的；很明显，我们将传递的线程函数通过lambda包装到了一起；注意当线程退出之后，对flag进行清理，以避免悬空指针；你也可以自定义join、detach、joinable以便用户进行选择。</p>

<h4 id="section-7">检测线程已被中断</h4>

<p>当<code class="highlighter-rouge">thread_local</code>标志被设置后，就可以通过<code class="highlighter-rouge">interruption_point</code>函数来制造一个中断点，通常你可以抛出一个异常来达到这一目的：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">interruption_point</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">throw</span> <span class="n">thread_interrupted</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>有了<code class="highlighter-rouge">interruption_point</code>这个函数，现在你可以将其放置在线程函数的主循环内：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">interruption_point</span><span class="p">();</span>
		<span class="n">process_next_item</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这样，当<code class="highlighter-rouge">thread_local</code>标志被设置后，线程函数就会抛出异常，停止运行，继而实现线程中断。<strong>中断线程最好的地方是线程阻塞的地方，因为这意味着线程没有在运行</strong>，所以是调用<code class="highlighter-rouge">interruption_point</code>最好的地方，你需要一种以可中断的方式等待某事的方法。</p>

<h4 id="condition-variable">中断一个condition variable的等待</h4>

<p>当线程在做一个阻塞等待的时候，<code class="highlighter-rouge">interruption_point</code>将找不到合适的位置进行调用，所以需要一个新的函数<code class="highlighter-rouge">interruptible_wait()</code>，该函数可以随时中断任何等待事件。</p>

<p>那么如何才能中断一个<code class="highlighter-rouge">condition_variable</code>的等待事件呢？一种简单的方法就是：一旦中断标志被设置，就立即notify这个<code class="highlighter-rouge">condition_variable</code>变量，并在这个<code class="highlighter-rouge">condition_variable</code>变量wait语句的后面立即调用<code class="highlighter-rouge">interruption_point</code>函数。要想这个方法能够生效，中断notify必须是<code class="highlighter-rouge">notify_all</code>，这样才能确保要中断的线程被中断了；<code class="highlighter-rouge">interrupt_flag</code>也需要保存一个<code class="highlighter-rouge">condition_variable</code>变量的指针，这样才能在set函数里面调用<code class="highlighter-rouge">notify_all</code>。</p>

<p>一个<code class="highlighter-rouge">interruptible_wait</code>的实现如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">interruption_point</span><span class="p">();</span>
	<span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">set_condition_variable</span><span class="p">(</span><span class="n">cv</span><span class="p">);</span>
	<span class="n">cv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
	<span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">clear_condition_variable</span><span class="p">();</span>
	<span class="n">interruption_point</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>很明显，该函数首先检查中断，然后关联中断flag到这个条件变量，做完等待后清除关联，这样能避免悬空指针，最后在做一次中断检查。这个函数看上去不错，但却是不可用的：</p>

<ul>
  <li>一个原因是因为条件变量的wait操作可能发生异常导致没有清除中断flag与条件变量的关联，继而导致悬空指针，你可以简单的将清除关联这个操作放到析构函数里面来解决这个问题；</li>
  <li>另一个不明显的原因是条件竞争：如果你在第一次中断检查之后、<code class="highlighter-rouge">cv.wait</code>之前，或者<code class="highlighter-rouge">cv.wait</code>之后、第二次中断检查之前进行中断，那么set函数中的<code class="highlighter-rouge">notify_all</code>就没有了作用(不久前我遇到过这种问题，我解决的方法是用<code class="highlighter-rouge">std::promise</code>，因为不管在get之前set还是在get之后set都没关系，但那个时候是一次set一次get，很显然这里可能set两次)，解决方法就是将wait改为<code class="highlighter-rouge">wait_for</code>，这样每隔一段时间就出来检查一下，不管什么时候进行中断，都能快速响应：</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="cp">#include &lt;atomic&gt;
#include &lt;condition_variable&gt;
#include &lt;future&gt;
</span>
<span class="k">class</span> <span class="nc">interrupt</span><span class="n">_flag</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="n">bool</span><span class="o">&gt;</span> <span class="n">flag</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">*</span> <span class="n">thread_cond</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">set_clear_mutex</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">interrupt_flag</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">thread_cond</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="kt">void</span> <span class="n">set</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">flag</span><span class="p">.</span><span class="n">store</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">set_clear_mutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">thread_cond</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">thread_cond</span><span class="o">-&gt;</span><span class="n">notify_all</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="n">is_set</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">flag</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">set_condition_variable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">set_clear_mutex</span><span class="p">);</span>
		<span class="n">thread_cond</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">clear_condition_variable</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">set_clear_mutex</span><span class="p">);</span>
		<span class="n">thread_cond</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="n">thread_local</span> <span class="n">interrupt_flag</span> <span class="n">this_thread_interrupt_flag</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">interruptible</span><span class="kr">_thread</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">internal_thread</span><span class="p">;</span>
	<span class="n">interrupt_flag</span><span class="o">*</span> <span class="n">flag</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">FunctionType</span><span class="o">&gt;</span>
	<span class="n">interruptible_thread</span><span class="p">(</span><span class="n">FunctionType</span> <span class="n">f</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">interrupt_flag</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">internal_thread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([</span><span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">]</span> <span class="p">{</span>
			<span class="n">p</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this_thread_interrupt_flag</span><span class="p">);</span>
			<span class="n">f</span><span class="p">();</span>
		<span class="p">});</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">interrupt</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flag</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">flag</span><span class="o">-&gt;</span><span class="n">set</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">~</span><span class="n">interruptible_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">flag</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">internal_thread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="n">internal_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">thread_interrupted</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">throw</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="s">"thread interrupted.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">interruption_point</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">throw</span> <span class="n">thread_interrupted</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">clear_cv_on_destruct</span>
<span class="p">{</span>
	<span class="o">~</span><span class="n">clear_cv_on_destruct</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">clear_condition_variable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Predicate</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span><span class="o">&amp;</span> <span class="n">cv</span><span class="p">,</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;&amp;</span> <span class="n">lk</span><span class="p">,</span>
	<span class="n">Predicate</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">interruption_point</span><span class="p">();</span>
	<span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">set_condition_variable</span><span class="p">(</span><span class="n">cv</span><span class="p">);</span>
	<span class="n">clear_cv_on_destruct</span> <span class="n">guard</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pred</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">cv</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">interruption_point</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>现在来对这个<code class="highlighter-rouge">interruptible_thread</code>做一个中断测试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "interrupt_thread.h"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">try</span> <span class="p">{</span>
			<span class="n">interruption_point</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">thread_interrupted</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">f</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span>
				<span class="n">std</span><span class="o">::</span><span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
			<span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>
	<span class="n">interruptible_thread</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">f</span><span class="p">)));</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">t</span><span class="p">.</span><span class="n">interrupt</span><span class="p">();</span>

	<span class="n">try</span> <span class="p">{</span>
		<span class="n">f</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">thread_interrupted</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>

<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>ew
thread interrupted.
</code></pre>
</div>

<p>答案是能够正常运行，为了将异常传递到主线程，我传递了一个promise变量，当中断发生的时候就设置一个异常在里面，在主线程调用get时就会重新抛出；<code class="highlighter-rouge">getchar()</code>用来控制中断发生的时间；如果foo由于其它异常导致退出以至于f没有调用<code class="highlighter-rouge">set_exception</code>，那么主线程将会一直在get处等待，当然这永远不会发生，因为foo不可能发生其他异常。</p>

<p>如果你想在foo中直接处理异常，也可以修改为如下代码，结果一样：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "interrupt_thread.h"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">try</span> <span class="p">{</span>
			<span class="n">interruption_point</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">thread_interrupted</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">interruptible_thread</span> <span class="n">t</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">t</span><span class="p">.</span><span class="n">interrupt</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>再做一个中断等待测试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "interrupt_thread.h"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mtx</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">try</span> <span class="p">{</span>
			<span class="n">interruptible_wait</span><span class="p">(</span><span class="n">cv</span><span class="p">,</span> <span class="n">lk</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span><span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">});</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">thread_interrupted</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">interruptible_thread</span> <span class="n">t</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">t</span><span class="p">.</span><span class="n">interrupt</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>asd
thread interrupted.
</code></pre>
</div>

<h4 id="section-8">中断其它阻塞调用</h4>

<p>除了<code class="highlighter-rouge">condition_variable</code>有wait操作外，<code class="highlighter-rouge">std::future</code>、<code class="highlighter-rouge">std::mutex</code>等也有wait操作，仿照条件变量的实现，future的实现也很容易：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">interruptible_wait</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">uf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">this_thread_interrupt_flag</span><span class="p">.</span><span class="n">is_set</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">==</span>
			<span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">interruption_point</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>然后稍微做个测试：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include "interrupt_thread.h"
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">uf</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">([]</span> <span class="p">{</span> <span class="c1">// future必须被赋值，不然将会抛出异常
</span>		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">++</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span>
				<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
			<span class="p">);</span>
		<span class="p">}</span>
	<span class="p">});</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">try</span> <span class="p">{</span>
			<span class="n">interruptible_wait</span><span class="p">(</span><span class="n">uf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">thread_interrupted</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">interruptible_thread</span> <span class="n">t</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="n">t</span><span class="p">.</span><span class="n">interrupt</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>d
thread interrupted.
</code></pre>
</div>

<h2 id="testing_and_debugging_multithreaded_applications">多线程程序的测试与调试</h2>

<h3 id="types_of_concurrency_related_bugs">与并发相关的错误类型</h3>

<p>与并发相关的错误类型通常分为两大类：</p>

<ul>
  <li>不必要的阻塞；</li>
  <li>条件竞争。</li>
</ul>

<h4 id="section-9">不必要的阻塞</h4>

<p>什么时候的阻塞是不必要的呢？</p>

<ul>
  <li>死锁(deadlock)：两个线程相互等待，使得都不能正常工作，这样的阻塞是不必要的；</li>
  <li>活锁(livelock)：活锁出现在无锁数据结构中，两个线程过独木桥，必须一个先过才能解决问题，不然就会一直不停循环，还会占用CPU，这样的阻塞也是不必要的；</li>
  <li>I/O或其它外部输入：如果线程A在等待输入，那么它就不能做事，这时如果另一个线程B在等待线程A执行某些操作，那么B的阻塞就是不必要的；</li>
</ul>

<h4 id="section-10">条件竞争</h4>

<p>条件竞争在多线程代码中很常见——很多条件竞争表现为死锁与活锁。但并非所有条件竞争都是恶性的，很多条件竞争是良性的，例如对任务列表中任务的竞争，不管哪个任务先执行都没有关系。</p>

<p>条件竞争通常会产生以下几种类型的错误：</p>

<ul>
  <li>数据竞争(data races)：如果并发的去修改一个独立对象，那么很可能某个线程在读取该对象时会读到错误的数据；</li>
  <li>破坏的不变量(broken invariants)：所谓不变量就是指状态很稳定，这个词不太好描述，之前的文章很少使用它，通俗一点就是–当前数据结构没有处于正在被修改状态。如果一个数据结构正在被一个线程修改，并且另一个线程能够看到该数据结构在修改过程中的中间状态，那么就称这个数据结构的不变量被破坏了。很明显，破坏的不变量可能导致读取到不正确的数据；</li>
  <li>生命周期问题(lifetime issues)：如果一个数据被删除或移动了，另一个线程还在对其进行访问，就会发生未定义行为。这通常发生在对局部变量的引用或其指针的传递使用上。</li>
</ul>

<h3 id="techniques_for_locating_concurrency_related_bugs">查找并发相关错误的技术</h3>

<p>查找bug最简单的方法就是直接查看代码，有时候你会需要一个<a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E9%BB%84%E9%B8%AD%E8%B0%83%E8%AF%95%E6%B3%95">小黄鸭</a>，但这只能找出很容易察觉的问题，很多设计上的问题是查找不出来的，你必须慢慢调试运行才能解决。</p>

<h4 id="review---">review 代码–发现潜在的错误</h4>

<p>在审阅多线程代码时，重点要检查与并发相关的错误。如果可能的话，找另一个人来检查，因为代码不是他写的，他就会思考这段代码时如何工作的，这就可能找出一些你没想到的bug。<strong>大多数并发bug需要足够的时间才能找出来</strong>。</p>

<p>如果你找不到人来检查你的代码(通常是这样的)，你可以先做一些其它的事，过了一段时间之后，可能是一小时、可能是一天、也可能是一周，你再回头来看这段代码，就可能从另一个角度来审视自己的代码。</p>

<p>另一种方法就是自己检查代码–你一行行的解释每行代码是如何工作的，交流的对象不必是人、甚至可以不存在，许多团队一般会有一只小熊或一只皮皮鸭。</p>

<p>review并发代码时需要思考的问题：</p>

<ul>
  <li>哪些数据会被并发访问？这些数据是否被正确保护了？</li>
  <li>哪些代码会被多个线程同时访问？会不会出现问题？</li>
  <li>当前线程持有哪些mutex？这些mutex是否被正确的lock与unlock了？</li>
  <li>两个线程间是否有操作的顺序要求(例如<code class="highlighter-rouge">contition_variable</code>的notify就必须在wait之后才有意义)，这个顺序是如何保证的？</li>
  <li>当前线程加载的数据是否仍然有效？它是否被其它线程修改了？</li>
  <li>假设其它线程能够修改这个数据，你是如何确保其不变量不被破坏的？</li>
</ul>

<p><strong>为了确保持有某个mutex时对一个数据的访问是安全的，你必须确保持持有另一个mutex的线程不能对这个数据进行访问</strong>，很明显这可能会破坏不变量。</p>

<p><strong>对公共数据的指针或引用需要特别小心</strong>。</p>

<p><strong>一个完整的操作不要分成多个步骤执行</strong>，这可能会造成条件竞争，就像<code class="highlighter-rouge">top</code>与<code class="highlighter-rouge">pop</code>一样，当你<code class="highlighter-rouge">top</code>完之后可能有其它线程做了<code class="highlighter-rouge">pop</code>，此时你再<code class="highlighter-rouge">pop</code>就可能删除还有用的数据。</p>

<h4 id="section-11">通过测试定位并发相关的错误</h4>

<p>测试多线程代码的难度要比单线程大好几个数量级，因为线程的调度情况会不断变化。由于与并发相关的bug相当难判断，所以在设计并发代码时需要格外谨慎，最好对每个功能块逐个测试，这样就能快速定位bug产生的地方。例如，对<code class="highlighter-rouge">threadsafe_queue</code>的测试就可以分为各个成员函数的测试。</p>

<p>有时候出现的问题并不一定是多线程bug产生的，你可以尝试用一个单线程来进行测试。</p>

<p>除了对并发的测试之外，对并发结构的测试也是很重要的。假设你要测试一个只包含push和pop的<code class="highlighter-rouge">threadsafe_queue</code>，那么你就需要考虑如下测试项：</p>

<ul>
  <li>单线程调用是否会出现问题；</li>
  <li>对于一个空queue，一个线程调用push，另一个线程调用pop，是否会出现问题；</li>
  <li>多个线程对一个空queue调用push；</li>
  <li>多个线程对一个满queue调用push；</li>
  <li>多个线程对一个空queue调用pop；</li>
  <li>多个线程对一个满queue调用pop；</li>
  <li>当任务数小于线程数时，多个线程对一个非满queue调用pop；</li>
  <li>多个线程对一个空queue调用push，同时一个线程调用pop；</li>
  <li>多个线程对一个满queue调用push，同时一个线程调用pop；</li>
  <li>多个线程同时对一个空queue分别调用push和pop；</li>
  <li>多个线程同时对一个满queue分别调用push和pop；</li>
</ul>

<p>这些测试项测试完毕之后，你还需要考虑测试环境的问题：</p>

<ul>
  <li>当前测试环境支持多少个线程同时运行？</li>
  <li>是否所有的线程都运行在单独的处理器上？</li>
  <li>测试需要什么样的处理器架构？</li>
  <li>在测试中如何对“同时”进行合理的安排？</li>
</ul>

<h4 id="section-12">设计容易进行测试的代码</h4>

<p>当代码满足一下几个条件时，会变得更加容易测试：</p>

<ul>
  <li>每个函数和类的职责都是明确的；</li>
  <li>函数简短扼要；</li>
  <li>你的测试能够完全控制测试代码周边的环境；</li>
  <li>执行特定操作的代码应该相互靠近，而不是散列分布；</li>
  <li>在写代码之前，思考一下怎样进行测试。</li>
</ul>

<p><strong>最好的测试并发代码的方法之一就是消除并发</strong>：如果你可以将代码分解为负责线程之间的通信的部分，以及在单线程中对传送的数据进行操作的部分，这样对数据操作的部分就能使用常规方法进行测试，线程间通信的部分也能更好的进行测试。</p>

<p>例如，当你测试一个状态机时，你可以将其分为几个部分：每个线程的状态逻辑可以使用单线程技术进行测试；线程间消息的传递可以使用多线程但是简单的状态逻辑进行测试，目标只是确认消息以正确的顺序传递到正确的线程即可。</p>

<p>如果你能将代码分为读共享数据、转换共享数据、更新共享数据三个板块，那么转换共享数据那块就能用单线程技术进行测试，这样并发测试也能减少到只测试共享数据的读和更新板块。总之，<strong>如果能将多线程代码分离出能够使用单线程进行测试的部分，就能更容易的进行测试</strong>。</p>

<p>需要注意的是：某些库会用其内部变量存储状态，如果多个线程使用相同的库，那么这些状态就会被共享，你应该在适当的时候添加一些保护和同步。</p>

<h4 id="section-13">多线程测试技术</h4>

<p>如何处理调度序列上的问题呢？</p>

<ul>
  <li>压力测试(brute-force testing)：多次运行测试代码，或者多个线程同时运行测试代码。如果存在调度序列上的bug，那么随着运行次数的增多，bug出现的几率就会越大；如果你运行几百上千次都没有问题，那么很可能这个代码就没有问题；<strong>但是需要确保不同的测试环境、以及代码的各个部分都被覆盖到，不然就会产生误导</strong>；</li>
  <li>结合仿真测试(combination simulation testing)：使用特殊的软件来模拟代码运行的真实情况。这种技术最适用于单个代码片段的细粒度测试，而不是整个应用程序；</li>
  <li>使用专用库对代码进行测试：这种测试虽然没有结合仿真测试那么详尽，但却可以使用特殊的实现来识别许多问题。例如，当一个共享数据被多个线程同时访问时，就需要一个特定的mutex，如果你能确认使用的是哪个mutex，一旦某个访问没有对该mutex进行上锁，你就能报告错误。通过某种方式标记这个共享数据，你就可以允许某个库进行检查。这样的库也能记录mutex上锁的顺序，当顺序不一致时，也能报告错误。</li>
</ul>

<h4 id="section-14">构建多线程测试代码</h4>

<p>一种<code class="highlighter-rouge">threadsafe_queue</code>的测试代码如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;cassert&gt;
</span>
<span class="cp">#include "myQueue.h"
</span>
<span class="kt">void</span> <span class="nf">test_concurrent_push_and_pop_on_empty_queue</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">threadsafe_queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">go</span><span class="p">,</span> <span class="n">push_ready</span><span class="p">,</span> <span class="n">pop_ready</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">ready</span><span class="p">(</span><span class="n">go</span><span class="p">.</span><span class="n">get_future</span><span class="p">());</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">push_done</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pop_done</span><span class="p">;</span>

	<span class="n">try</span>
	<span class="p">{</span>
		<span class="n">push_done</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
			<span class="p">[</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">ready</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">push_ready</span><span class="p">]()</span>
		<span class="p">{</span>
			<span class="n">push_ready</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
			<span class="n">ready</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="p">);</span>

		<span class="n">pop_done</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
			<span class="p">[</span><span class="o">&amp;</span><span class="n">q</span><span class="p">,</span> <span class="n">ready</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pop_ready</span><span class="p">]()</span>
		<span class="p">{</span>
			<span class="n">pop_ready</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
			<span class="n">ready</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
			<span class="k">return</span> <span class="o">*</span><span class="n">q</span><span class="p">.</span><span class="n">wait_and_pop</span><span class="p">();</span>			
		<span class="p">}</span>
		<span class="p">);</span>

		<span class="n">push_ready</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
		<span class="n">pop_ready</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">wait</span><span class="p">();</span>
		<span class="n">go</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span> <span class="c1">// 确保push和pop同时运行
</span>
		<span class="n">push_done</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">pop_done</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span>
		<span class="n">assert</span><span class="p">(</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(...)</span>
	<span class="p">{</span>
		<span class="n">go</span><span class="p">.</span><span class="n">set_value</span><span class="p">();</span>
		<span class="k">throw</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">test_concurrent_push_and_pop_on_empty_queue</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="section-15">测试多线程代码性能</h4>

<p>测试多线程代码的可扩展性是非常有必要的，通过在不同处理器数量的系统上进行测试，你可以得到一张性能扩展图。</p>

<p><strong>你至少需要在一个单处理器系统和一个多处理器系统上进行测试</strong>。</p>


                <hr>



                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/06/08/C++-thread-design-2/" data-toggle="tooltip" data-placement="top" title="C++ 多线程设计（二）">
                        Previous<br>
                        <span>C++ 多线程设计（二）</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/08/28/Qt5-basis/" data-toggle="tooltip" data-placement="top" title="Qt5 基础篇">
                        Next<br>
                        <span>Qt5 基础篇</span>
                        </a>
                    </li>
                    
                </ul>



                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#Python" title="Python" rel="1">
                                    Python
                                </a>
                            
        				
                            
                				<a href="/tags/#Markdown" title="Markdown" rel="1">
                                    Markdown
                                </a>
                            
        				
                            
                				<a href="/tags/#C++" title="C++" rel="9">
                                    C++
                                </a>
                            
        				
                            
                				<a href="/tags/#C++ primer" title="C++ primer" rel="4">
                                    C++ primer
                                </a>
                            
        				
                            
                				<a href="/tags/#thread" title="thread" rel="4">
                                    thread
                                </a>
                            
        				
                            
                				<a href="/tags/#Qt5" title="Qt5" rel="1">
                                    Qt5
                                </a>
                            
        				
                            
                				<a href="/tags/#git" title="git" rel="1">
                                    git
                                </a>
                            
        				
                            
                				<a href="/tags/#shell" title="shell" rel="1">
                                    shell
                                </a>
                            
        				
                            
                				<a href="/tags/#algorithm" title="algorithm" rel="1">
                                    algorithm
                                </a>
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://huangxuan.me">Hux Blog</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>





<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "blog-pengzhen";
    var disqus_identifier = "/2017/07/06/C++-thread-application";
    var disqus_url = "https://chorior.github.io/2017/07/06/C++-thread-application/";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->






    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                     
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/Chorior">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/Chorior">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Chorior 2019
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-92626017-1';
    var _gaDomain = 'auto';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0" /> -->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
