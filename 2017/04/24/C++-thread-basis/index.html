<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="学习使我快乐">
    <meta name="keywords"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>C++ 多线程基础篇 - 彭侦的博客 | PengZhen's Blog</title>

    <link rel="canonical" href="https://chorior.github.io/2017/04/24/C++-thread-basis/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <!--<link href="http://cdn.staticfile.org/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">-->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">PengZhen's Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __FishNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __FishNav__.close()
        }else{
            __FishNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close FishNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __FishNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/stock-photo-4.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/stock-photo-4.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#C++" title="C++">C++</a>
                        
                        <a class="tag" href="/tags/#thread" title="thread">thread</a>
                        
                    </div>
                    <h1>C++ 多线程基础篇</h1>
                    
                    
                    <h2 class="subheading">Concurrency In Action</h2>
                    
                    <span class="meta">Posted by pengzhen on April 24, 2017</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

				<p>本文知识来自<a href="https://chenxiaowei.gitbooks.io/cpp_concurrency_in_action/content/">C++ Concurrency In Action</a>，介绍有关C++11多线程(multithreading)相关的知识。</p>

<h1 id="section">本文结构</h1>

<ul>
  <li><a href="#multithreading_overview">多线程概述</a>
    <ul>
      <li><a href="#basic_conception">基本概念</a></li>
      <li><a href="#two_ways_to_use_concurrency">使用并发的两种方法</a></li>
      <li><a href="#two_reason_to_use_concurrency">使用并发的两种原因</a></li>
      <li><a href="#weak_points_of_concurrency">并发的缺点</a></li>
      <li><a href="#hello_world">Hello, world</a></li>
    </ul>
  </li>
  <li><a href="#managing_threads">多线程管理</a>
    <ul>
      <li><a href="#std_thread">std::thread</a></li>
      <li><a href="#start_a_thread">线程启动</a></li>
      <li><a href="#deal_thread_exception">异常处理</a></li>
      <li><a href="#thread_identification">多线程识别</a></li>
    </ul>
  </li>
  <li><a href="#sharing_data_between_threads">线程间共享数据</a>
    <ul>
      <li><a href="#std_mutex">std::mutex</a></li>
      <li><a href="#api_design_with_mutex">与mutex相关的接口设计</a></li>
      <li><a href="#dead_lock">死锁</a></li>
      <li><a href="#advanced_guide_of_dead_lock">避免死锁的进阶指导</a></li>
      <li><a href="#std_unique_lock">std::unique_lock</a></li>
      <li><a href="#std_onceflag_and_callonce">std::once_flag,std::call_once</a></li>
      <li><a href="#boost_shared_mutex">boost::shared_mutex</a></li>
    </ul>
  </li>
  <li><a href="#synchronizing_thread">多线程同步</a>
    <ul>
      <li><a href="#condition_variable">条件变量(condition variable)</a></li>
      <li><a href="#future">期望(future)</a></li>
      <li><a href="#std_future">std::future</a></li>
      <li><a href="#std_packaged_task">std::packaged_task</a></li>
      <li><a href="#std_promise">std::promise</a></li>
      <li><a href="#save_exception_for_future">future存储异常</a></li>
      <li><a href="#std_shared_future">std::shared_future</a></li>
    </ul>
  </li>
  <li><a href="#wait_with_time_limit">限定等待时间</a>
    <ul>
      <li><a href="#clock">时钟(clock)</a></li>
      <li><a href="#duration">持续时间(duration)</a></li>
      <li><a href="#time_point">时间点(time point)</a></li>
      <li><a href="#function_accept_timeouts">具有超时功能的函数</a></li>
    </ul>
  </li>
  <li><a href="#simplify_code_with_synchronization">使用同步操作简化代码</a>
    <ul>
      <li><a href="#functional_program_with_future">使用future的函数化编程(functional programming)</a></li>
      <li><a href="#synchronize_operations_with_message_passing">状态机</a></li>
    </ul>
  </li>
</ul>

<h2 id="multithreading_overview">多线程概述</h2>

<h3 id="basic_conception">基本概念</h3>

<p>并发：<strong>同一时间内发生两个或更多独立的活动</strong>；</p>

<p>任务切换: 每个任务交织进行,但切换会有时间开销；</p>

<p>硬件并发(hardware concurrency): 真正的并行多个任务。</p>

<p><strong>即便是具有真正硬件并发的系统，有时候也会需要任务切换</strong>；</p>

<h3 id="two_ways_to_use_concurrency">使用并发的两种方法</h3>

<p>将应用程序分为多个独立的进程,它们在同一时刻运行</p>

<ul>
  <li>
    <p>缺点</p>

    <ul>
      <li>进程间通信设置复杂，速度慢，因为系统在进程间提供了很多保护措施用以保护数据；</li>
      <li>运行多个进程需要固定开销：需要时间启动进程，操作系统需要内部资源来管理进程，等等；</li>
    </ul>
  </li>
  <li>
    <p>优点</p>

    <ul>
      <li>更容易编写安全(safe)的并发代码；</li>
      <li>可以使用远程连接(可能需要联网)，在不同的机器上运行独立的进程；</li>
    </ul>
  </li>
</ul>

<p>在单个进程中运行多个线程</p>

<ul>
  <li>
    <p>缺点</p>

    <ul>
      <li>进程中的所有线程都共享地址空间；</li>
      <li>如果数据要被多个线程访问，那么必须确保每个线程所访问到的数据是一致的；</li>
    </ul>
  </li>
  <li>
    <p>优点</p>

    <ul>
      <li>使用多线程相关的开销远远小于使用多个进程；</li>
      <li>全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</li>
    </ul>
  </li>
</ul>

<p><strong>C++标准并未对进程间通信提供任何原生支持</strong>。</p>

<h3 id="two_reason_to_use_concurrency">使用并发的两种原因</h3>

<p>分离关注点(separation of concerns(SOC))</p>

<ul>
  <li>将相关的代码与无关的代码分离，使程序更容易理解和测试，减少出错的可能性；</li>
  <li>独立的线程通常用来执行那些必须在后台持续运行的任务，如socket服务器。</li>
</ul>

<p>提升性能</p>

<ul>
  <li>任务并行(task parallelism)：将单个任务分成多个部分且各自并行运行，从而降低总运行时间；</li>
  <li>数据并行(data parallelism)：同时对多组数据执行相同的操作。</li>
</ul>

<h3 id="weak_points_of_concurrency">并发的缺点</h3>

<ul>
  <li>如果在线程上的任务完成得很快，那么任务实际执行的时间要比启动线程的时间小很多；</li>
  <li>运行太多的线程会耗尽进程的可用内存或地址空间(<strong>可以使用线程池来限定线程数量</strong>)；</li>
  <li>线程数越多，操作系统就需要做越多的上下文切换；</li>
  <li><strong>使用并发可能使代码复杂化、更难理解，并且更容易出错</strong>。</li>
</ul>

<p><strong>当并发收益小于实际开发和维护的成本时，不要使用并发</strong>。</p>

<p><strong>在绝大多数情况下，额外增加的复杂性和出错几率都远大于性能的小幅提升带来的收益</strong>。</p>

<h3 id="hello_world">Hello, world</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;thread&gt;
</span>
<span class="kt">void</span> <span class="nf">hello</span><span class="p">()</span> <span class="p">{</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello Concurrent World!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">hello</span><span class="p">);</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<ul>
  <li>g++编译时须加上<code class="highlighter-rouge">-pthread -std=c++11</code>；</li>
  <li>管理线程的函数和类在<code class="highlighter-rouge">&lt;thread&gt;</code>中声明，而保护共享数据的函数和类在其他头文件中声明；</li>
  <li>初始线程始于<code class="highlighter-rouge">main()</code>，新线程始于<code class="highlighter-rouge">hello()</code>；</li>
  <li><code class="highlighter-rouge">join()</code>使得初始线程必须等待新线程结束后，才能运行下面的语句或结束自己的线程；</li>
  <li>该示例使用多线程并没有带来任何收益；</li>
  <li><strong>使用多线程并不复杂，复杂的是如何设计代码以实现其预期的行为</strong>。</li>
</ul>

<h2 id="managing_threads">多线程管理</h2>

<h3 id="std_thread">std::thread</h3>

<p><strong>每个程序至少有一个线程：执行main()函数的线程</strong>，其余线程有其各自的入口函数。线程与原始线程(以main()为入口函数的线程)同时运行。如同main()函数执行完会退出一样，当线程执行完入口函数后，线程也会退出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 标准库thread类
</span><span class="k">class</span> <span class="nc">thread</span>
<span class="p">{</span>	<span class="c1">// class for observing and managing threads
</span><span class="nl">public:</span>
	<span class="k">class</span> <span class="nc">id</span><span class="p">;</span>

	<span class="k">typedef</span> <span class="kt">void</span> <span class="o">*</span><span class="n">native_handle_type</span><span class="p">;</span>

	<span class="kr">thread</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// construct with no thread
</span>		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Fn</span><span class="p">,</span>
		<span class="k">class</span><span class="err">...</span> <span class="nc">_Args</span><span class="p">,</span>
		<span class="k">class</span> <span class="err">=</span> <span class="nc">typename</span> <span class="n">enable_if</span><span class="o">&lt;</span>
		<span class="o">!</span><span class="n">is_same</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">decay</span><span class="o">&lt;</span><span class="n">_Fn</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="kr">thread</span><span class="o">&gt;::</span><span class="n">value</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&gt;</span>
		<span class="k">explicit</span> <span class="kr">thread</span><span class="p">(</span><span class="n">_Fn</span><span class="o">&amp;&amp;</span> <span class="n">_Fx</span><span class="p">,</span> <span class="n">_Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">_Ax</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// construct with _Fx(_Ax...)
</span>		<span class="n">_Launch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_Thr</span><span class="p">,</span>
			<span class="n">_STD</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">_Fn</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">decay_t</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">...</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span>
				<span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">_Fn</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Fx</span><span class="p">),</span> <span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">_Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Ax</span><span class="p">)...));</span>
	<span class="p">}</span>


	<span class="o">~</span><span class="kr">thread</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// clean up
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">joinable</span><span class="p">())</span>
			<span class="n">_XSTD</span> <span class="n">terminate</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kr">thread</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
		<span class="o">:</span> <span class="n">_Thr</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// move from _Other
</span>		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kr">thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// move from _Other
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">_Move_thread</span><span class="p">(</span><span class="n">_Other</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kr">thread</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="kr">thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="kr">thread</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="kr">thread</span><span class="o">&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// swap with _Other
</span>		<span class="n">_STD</span> <span class="n">swap</span><span class="p">(</span><span class="n">_Thr</span><span class="p">,</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="n">joinable</span><span class="p">()</span> <span class="k">const</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if this thread can be joined
</span>		<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="n">_Thr_is_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">join</span><span class="p">()</span>
	<span class="p">{</span>   <span class="c1">// join thread
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">joinable</span><span class="p">())</span>
			<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_INVALID_ARGUMENT</span><span class="p">);</span>

		<span class="c1">// Avoid Clang -Wparentheses-equality
</span>		<span class="k">const</span> <span class="n">bool</span> <span class="n">_Is_null</span> <span class="o">=</span> <span class="n">_Thr_is_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_Is_null</span><span class="p">)</span>
			<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_INVALID_ARGUMENT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_id</span><span class="p">()</span> <span class="o">==</span> <span class="n">_STD</span> <span class="n">this_thread</span><span class="o">::</span><span class="n">get_id</span><span class="p">())</span>
			<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_RESOURCE_DEADLOCK_WOULD_OCCUR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">_Thrd_join</span><span class="p">(</span><span class="n">_Thr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">_Thrd_success</span><span class="p">)</span>
			<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_NO_SUCH_PROCESS</span><span class="p">);</span>
		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">detach</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// detach thread
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">joinable</span><span class="p">())</span>
			<span class="n">_Throw_Cpp_error</span><span class="p">(</span><span class="n">_INVALID_ARGUMENT</span><span class="p">);</span>
		<span class="n">_Thrd_detachX</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>
		<span class="n">_Thr_set_null</span><span class="p">(</span><span class="n">_Thr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">id</span> <span class="n">get_id</span><span class="p">()</span> <span class="k">const</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return id for this thread
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">_Thr_val</span><span class="p">(</span><span class="n">_Thr</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hardware_concurrency</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return number of hardware thread contexts
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">_Thrd_hardware_concurrency</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">native_handle_type</span> <span class="n">native_handle</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// return Win32 HANDLE as void *
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">_Thr</span><span class="p">.</span><span class="n">_Hnd</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre>
</div>

<p>通过查看thread类的公有成员，我们得知：</p>

<ul>
  <li><strong>thread类包含三个构造函数</strong>：一个默认构造函数(什么都不做)、一个接受可调用对象及其参数的explicit构造函数(参数可能没有，这时相当于<a href="https://chorior.github.io/2017/04/04/C++-%E9%87%8A%E7%96%91-%E4%B8%89/#type_conversion">转换构造函数</a>，所以需要定义为explicit)、和一个移动构造函数；</li>
  <li><strong>析构函数会在thread对象销毁时自动调用，如果销毁时thread对象还是joinable，那么程序会调用terminate()终止进程</strong>；</li>
  <li>thread类没有拷贝操作，只有移动操作，即<strong>thread对象是可移动不可拷贝的</strong>，这保证了在同一时间点，一个thread实例只能关联一个执行线程；</li>
  <li>swap函数用来交换两个thread对象管理的线程；</li>
  <li>joinable函数用来判断该thread对象是否是可加入的；</li>
  <li>join函数使得该thread对象管理的线程加入到原始线程，<strong>只能使用一次</strong>，并使joinable为false；</li>
  <li>detach函数使得该thread对象管理的线程<strong>与原始线程分离，独立运行</strong>，并使joinable为false；</li>
  <li><code class="highlighter-rouge">get_id</code>返回线程标识；</li>
  <li><code class="highlighter-rouge">hardware_concurrency</code>返回能同时并发在一个程序中的线程数量，当系统信息无法获取时，函数也会返回0。<strong>注意其是<code class="highlighter-rouge">static</code>修饰的，应该这么使用–<code class="highlighter-rouge">std::thread::hardware_concurrency()</code></strong>。</li>
</ul>

<p><strong>调用<code class="highlighter-rouge">join()</code>清理了与线程相关的存储部分，所以该thread对象不再与任何线程相关联直到重新赋值</strong> 。</p>

<p>detach线程又称守护线程(daemon threads)，<strong>C++运行库保证，当detach线程退出时，相关资源能够正确回收、后台线程的归属和控制都会由C++运行库进行处理</strong>。</p>

<h3 id="start_a_thread">线程启动</h3>

<p><strong>使用C++线程库开启一个线程通常归结为构造一个<code class="highlighter-rouge">std::thread</code>类对象</strong>。</p>

<p>由于thread类只有一个有用的构造函数，所以只能使用可调用对象来构造thread对象。</p>

<p>可调用对象包括：</p>

<ul>
  <li>函数</li>
  <li>函数指针</li>
  <li>lambda表达式</li>
  <li>bind创建的对象</li>
  <li>重载了函数调用符的类</li>
</ul>

<p><strong>如果参数需要转换才能匹配函数,最好使用显式转换</strong>,因为默认转换也许在没有转换成功之前住线程就结束了；<strong>如果线程参数是引用类型,传递参数时,一定要使用<code class="highlighter-rouge">std::ref(arg)</code></strong>；<strong>如果线程函数是成员函数，那么需要传递一个合适的对象实例指针,后跟成员函数参数</strong>。</p>

<p>根据析构函数，可以知道：<strong>在构造一个thread对象之后，需要决定调用<code class="highlighter-rouge">join()</code>或是<code class="highlighter-rouge">detach()</code></strong>。如果要调用<code class="highlighter-rouge">detach()</code>，那么需要保证线程结束之前，可访问的数据的有效性，举个栗子，<strong>detach的线程如果包含原始线程的局部变量的指针或引用，就会很大概率出现问题</strong>。</p>

<p><strong>detach的线程通常将要用的数据全部复制到自己的线程中</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 线程启动示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;thread&gt;
#include &lt;string&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"add: "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">"/"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="s">" = "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>

<span class="k">struct</span> <span class="n">mod</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"mod: "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">noargs</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="k">operator</span><span class="p">()()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"voidreturn() called.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">test</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">do_something</span><span class="p">(</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">func_ptr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">add</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">lambda</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lambda: "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="p">};</span>
	<span class="k">auto</span> <span class="n">obj_bind</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_2</span><span class="p">,</span> <span class="n">placeholders</span><span class="o">::</span><span class="n">_1</span><span class="p">);</span>

	<span class="c1">// 这里都用了移动赋值运算符
</span>	<span class="k">auto</span> <span class="n">t0</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">divide</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">func_ptr</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t3</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">obj_bind</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t4</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">mod</span><span class="p">(),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t5</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t6</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">((</span><span class="n">noargs</span><span class="p">()));</span>
	<span class="c1">// auto t6 = thread{noargs()}; // 正确
</span>	<span class="c1">// thread t6(noargs());        // 会被解析为函数声明！	
</span>	<span class="n">string</span> <span class="n">str</span><span class="p">{</span> <span class="s">"hahaha"</span> <span class="p">};</span>
	<span class="k">auto</span> <span class="n">t7</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">test</span><span class="o">::</span><span class="n">do_something</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

	<span class="n">t0</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t4</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t5</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t6</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t7</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>由于<code class="highlighter-rouge">std::cout</code>是共用的标准输出，所以会造成竞争，结果打印出来的结果可能会很乱：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>4/lambda: 123hahaha
voidreturn() called.
add: 7
 = 1
3/4 = 0

mod: 1


</code></pre>
</div>

<h3 id="deal_thread_exception">异常处理</h3>

<p><strong>如果在thread对象join或者detach之前，原始线程发生了异常，那么C++会使用栈的方式对对象进行销毁，这时因为thread对象还是joinable的，所以销毁thread对象会调用<code class="highlighter-rouge">terminate()</code></strong>。为了避免这样的情况，程序员通常使用两种方式来解决这个问题：</p>

<ul>
  <li>使用异常处理，try-catch；</li>
  <li>构造一个类，在析构函数里调用join或detach(<strong>推荐</strong>)。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 异常处理
</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">my_func</span><span class="p">);</span>
<span class="n">try</span>
<span class="p">{</span>
    <span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  
    <span class="k">throw</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

<span class="c1">// 构造类
</span><span class="k">class</span> <span class="nc">scoped</span><span class="kr">_thread</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">scoped_thread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t_</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
			<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">"No thread"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">~</span><span class="n">scoped_thread</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">scoped_thread</span><span class="p">(</span><span class="n">scoped_thread</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">scoped_thread</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">scoped_thread</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>  
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">my_func</span><span class="p">);</span>
    <span class="n">scoped_thread</span> <span class="n">g</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">t</span><span class="p">));</span>
    <span class="n">do_something_in_current_thread</span><span class="p">();</span>
<span class="p">}</span> 
</code></pre>
</div>

<h3 id="thread_identification">多线程识别</h3>

<p>线程标识类型是<code class="highlighter-rouge">std::thread::id</code>，这个值可以通过两种方式进行检索：</p>

<ul>
  <li>成员函数<code class="highlighter-rouge">std::thread::get_id()</code>，当没有线程与该thread对象关联时，此函数返回0；</li>
  <li>命名空间函数<code class="highlighter-rouge">std::this_thread::get_id()</code>。</li>
</ul>

<p><strong>如果两个对象的<code class="highlighter-rouge">std::thread::id</code>相等，那它们就是同一个线程，或者都“没有线程”。如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// std::thread::id 支持的各种操作
</span><span class="kr">inline</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Left</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if _Left and _Right identify the same thread
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Left</span><span class="p">.</span><span class="n">_Id</span> <span class="o">==</span> <span class="n">_Right</span><span class="p">.</span><span class="n">_Id</span><span class="p">);</span>
	<span class="p">}</span>

<span class="kr">inline</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Left</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if _Left and _Right do not identify the same thread
</span>	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_Left</span> <span class="o">==</span> <span class="n">_Right</span><span class="p">));</span>
	<span class="p">}</span>

<span class="kr">inline</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Left</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if _Left precedes _Right
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Left</span><span class="p">.</span><span class="n">_Id</span> <span class="o">&lt;</span> <span class="n">_Right</span><span class="p">.</span><span class="n">_Id</span><span class="p">);</span>
	<span class="p">}</span>

<span class="kr">inline</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">&lt;=</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Left</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if _Left precedes or equals _Right
</span>	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_Right</span> <span class="o">&lt;</span> <span class="n">_Left</span><span class="p">));</span>
	<span class="p">}</span>

<span class="kr">inline</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">&gt;</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Left</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if _Left follows _Right
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Right</span> <span class="o">&lt;</span> <span class="n">_Left</span><span class="p">);</span>
	<span class="p">}</span>

<span class="kr">inline</span> <span class="n">bool</span> <span class="k">operator</span><span class="o">&gt;=</span><span class="p">(</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Left</span><span class="p">,</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if _Left follows or equals _Right
</span>	<span class="k">return</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">_Left</span> <span class="o">&lt;</span> <span class="n">_Right</span><span class="p">));</span>
	<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ch</span><span class="p">,</span>
	<span class="k">class</span> <span class="nc">_Tr</span><span class="o">&gt;</span>
	<span class="n">basic_ostream</span><span class="o">&lt;</span><span class="n">_Ch</span><span class="p">,</span> <span class="n">_Tr</span><span class="o">&gt;&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span>
		<span class="n">basic_ostream</span><span class="o">&lt;</span><span class="n">_Ch</span><span class="p">,</span> <span class="n">_Tr</span><span class="o">&gt;&amp;</span> <span class="n">_Str</span><span class="p">,</span>
		<span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">_Id</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// insert id into stream
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Id</span><span class="p">.</span><span class="n">_To_text</span><span class="p">(</span><span class="n">_Str</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="c1">// TEMPLATE STRUCT SPECIALIZATION hash
</span><span class="k">template</span><span class="o">&lt;&gt;</span>
	<span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kr">thread</span><span class="o">::</span><span class="n">id</span><span class="o">&gt;</span>
	<span class="p">{</span>	<span class="c1">// hash functor for thread::id
</span>	<span class="k">typedef</span> <span class="kr">thread</span><span class="o">::</span><span class="n">id</span> <span class="n">argument_type</span><span class="p">;</span>
	<span class="k">typedef</span> <span class="kt">size_t</span> <span class="n">result_type</span><span class="p">;</span>

	<span class="kt">size_t</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">argument_type</span><span class="o">&amp;</span> <span class="n">_Keyval</span><span class="p">)</span> <span class="k">const</span>
		<span class="p">{</span>	<span class="c1">// hash _Keyval to size_t value by pseudorandomizing transform
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">_Keyval</span><span class="p">.</span><span class="n">_Hash_id</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">};</span>
</code></pre>
</div>

<p>查看<code class="highlighter-rouge">std::thread::id</code>源代码，发现其支持<code class="highlighter-rouge">==,!=,&lt;,&lt;=,&gt;,&gt;=,&lt;&lt;</code>运算符，还定义了hash模板的特例化版本，所以<strong><code class="highlighter-rouge">std::thread::id</code>支持各种算法和无序容器，甚至可以用来作为键值</strong>。</p>

<h2 id="sharing_data_between_threads">线程间共享数据</h2>

<p><strong>条件竞争(race condition)：当一个线程A正在修改共享数据时，另一个线程B却在使用这个共享数据，这时B访问到的数据可能不是正确的数据，这种情况称为条件竞争</strong>。</p>

<p><strong>数据竞争(data race)：一种特殊的条件竞争，并发的去修改一个独立对象</strong>。</p>

<p>多线程的一个关键优点(key benefit)是可以简单的直接共享数据，但<strong>如果有多个线程拥有修改共享数据的权限，那么就会很容易出现数据竞争(data race)</strong>。</p>

<h3 id="std_mutex">std::mutex</h3>

<p><strong>C++保护共享数据最基本的技巧是使用互斥量(mutex)</strong>：访问共享数据前，使用互斥量将相关数据锁住，当访问结束后，再将数据解锁。<strong>当一个线程使用特定互斥量锁住共享数据时，其他线程要想访问锁住的数据，必须等到之前那个线程对数据进行解锁后，才能进行访问</strong>。</p>

<p>在C++中使用互斥量</p>

<ul>
  <li>创建互斥量：即构建一个<code class="highlighter-rouge">std::mutex</code>实例；</li>
  <li>锁住互斥量：调用成员函数<code class="highlighter-rouge">lock()</code>；</li>
  <li>释放互斥量：调用成员函数<code class="highlighter-rouge">unlock()</code>；</li>
  <li>由于<code class="highlighter-rouge">lock()</code>与<code class="highlighter-rouge">unlock()</code>必须配对，就像new和delete一样，所以为了方便和异常处理，<strong>C++标准库也专门提供了一个模板类<code class="highlighter-rouge">std::lock_guard</code></strong>，其在构造时lock互斥量,析构时unlock互斥量。</li>
</ul>

<p><code class="highlighter-rouge">std::mutex</code>和<code class="highlighter-rouge">std::lock_guard</code>定义于头文件<code class="highlighter-rouge">&lt;mutex&gt;</code>中。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// std::mutex 使用示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;set&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Example</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">mySet</span><span class="p">;</span>
	<span class="n">mutex</span> <span class="n">myMutex</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">Example</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="o">~</span><span class="n">Example</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">Example</span><span class="p">(</span><span class="k">const</span> <span class="n">Example</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">Example</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Example</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">add_to_set</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lg</span><span class="p">(</span><span class="n">myMutex</span><span class="p">);</span>
		<span class="n">mySet</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="nf">set_contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lg</span><span class="p">(</span><span class="n">myMutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">mySet</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mySet</span><span class="p">.</span><span class="n">cend</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">print_set</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lg</span><span class="p">(</span><span class="n">myMutex</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">i</span> <span class="o">:</span> <span class="n">mySet</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">thread1</span><span class="p">(</span><span class="n">Example</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">e</span><span class="p">.</span><span class="n">add_to_set</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">thread2</span><span class="p">(</span><span class="n">Example</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">set_contains</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>		
	<span class="n">Example</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">thread1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">thread2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="n">e</span><span class="p">.</span><span class="n">print_set</span><span class="p">();</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>示例结果如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1111111111
0 1 2 3 4 5 6 7 8 9
</code></pre>
</div>

<p><strong>具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制</strong>，所以接口的设计一定要确保互斥量能锁住任何对保护数据的访问，并且不留后门。</p>

<p><strong>切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 错误示例
// 假设Example定义了set&lt;int&gt;* get_set(){return &amp;mySet;} 
</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">is</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">get_set</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">thread1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
<span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="kr">thread</span><span class="p">(</span><span class="n">thread2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
<span class="n">is</span><span class="o">-&gt;</span><span class="n">erase</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre>
</div>

<p>结果可能跟最初的意图不太一样：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>1101111111
0 1 3 4 5 6 7 8 9
</code></pre>
</div>

<h3 id="api_design_with_mutex">与mutex相关的接口设计</h3>

<p>假设有一个stack，它的所有操作(push,top,pop等)都使用了mutex进行保护，但是下面的代码在并发的情况下依然会出现错误：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">()){</span>
	<span class="kt">int</span> <span class="k">const</span> <span class="n">value</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> 
	<span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="n">do_something</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>在调用<code class="highlighter-rouge">empty()</code>和<code class="highlighter-rouge">top()</code>之间，或者调用<code class="highlighter-rouge">top()</code>与<code class="highlighter-rouge">pop()</code>之间，可能有来自另一个线程的<code class="highlighter-rouge">pop()</code>调用并删除了最后一个元素。这是接口设计造成的条件竞争(race condition)。</p>

<p>之所以将<code class="highlighter-rouge">top()</code>和<code class="highlighter-rouge">pop()</code>分为两部分(好像java就是合成一个函数的)，是为了防止在单线程中top发生异常时，保证数据没有丢失，但这在多线程中造成了条件竞争。</p>

<p>解决这个问题的方案就是将<code class="highlighter-rouge">top()</code>和<code class="highlighter-rouge">pop()</code>合成一个函数，并在pop之前就将数据传递出去(参数引用或指针返回)，这时就算top发生异常也不会造成数据丢失：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#pragma once
</span>
<span class="c1">// 一个线程安全的栈的简单设计
</span><span class="cp">#include &lt;exception&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;stack&gt;
</span>
<span class="k">struct</span> <span class="n">empty_stack</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
	<span class="c1">// 老版本使用throw()代替noexcept
</span>	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="n">noexcept</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">"empty stack!"</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe</span><span class="n">_stack</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">threadsafe_stack</span><span class="p">()</span>
		<span class="o">:</span> <span class="n">data</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>

	<span class="n">threadsafe_stack</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>
		<span class="n">data</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">data</span><span class="p">;</span> <span class="c1">// 在构造函数体中执行拷贝，而非使用成员初始化，这样安全
</span>	<span class="p">}</span>

	<span class="c1">// 栈不能直接赋值
</span>	<span class="n">threadsafe_stack</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_stack</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="n">data</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span> <span class="c1">// 在调用top前，检查栈是否为空
</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> <span class="c1">// 就算T的拷贝或移动赋值运算符发生异常，数据也不会丢失
</span>		<span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// 不返回值是为了防止T的拷贝或移动构造函数发生异常
</span>	<span class="c1">// 如果T的拷贝或移动构造函数都是noexcept的，那么可以返回值
</span>	<span class="c1">// 返回shared_ptr是为了方便内存管理
</span>	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">pop</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="k">throw</span> <span class="n">empty_stack</span><span class="p">();</span>

		<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">res</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">top</span><span class="p">()));</span>
		<span class="n">data</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">data</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<p><strong>互斥量保护的粒度不能太小，那样保护不完全；也不能太大，那样会降低性能；对于非共享数据的操作，就不需要互斥量保护；但是要确保一个操作的结果是正确的</strong>。</p>

<p>粒度：通过一个锁保护着的数据量的大小。</p>

<h3 id="dead_lock">死锁</h3>

<p><strong>死锁(deadlock)：两个线程相互等待，导致两个线程都无法正常工作</strong>。</p>

<p><strong>如果一个操作需要锁住两个或更多互斥量，那么可能会造成死锁</strong>。假设一个数据由两个锁A和B进行保护，此时一个线程以先A后B的顺序进行上锁，另一个线程以先B后A的顺序进行上锁，那么当前一个线程在对A上锁后、对B上锁前的时候，后一个线程对B上了锁，那么前一个线程会等待后一个线程对B解锁，而后一个线程会等待前一个线程对A解锁，这就造成了无止境的等待，即死锁现象。</p>

<p>避免死锁的一般方法是：<strong>避免使用多个互斥量，如果一定要的话，让互斥量总是以相同的顺序上锁</strong>。<strong>标准库函数<code class="highlighter-rouge">std::lock(mutexs)</code>可以一次性锁住两个或更多互斥量，且不会有死锁的危险</strong>，所以<strong>如果一个操作确实需要两个或更多互斥量，建议使用<code class="highlighter-rouge">std::lock(mutexs)</code></strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// std::lock(mutexs) 示例
</span><span class="k">class</span> <span class="nc">some</span><span class="n">_big_object</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">some_big_object</span> <span class="n">some_detail</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">X</span><span class="p">(</span><span class="n">some_big_object</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sd</span><span class="p">)</span> <span class="o">:</span><span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{}</span>

	<span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// 同一线程如果已经对一个mutex进行lock操作
</span>		<span class="c1">// 再次对其进行lock操作会引发未定义行为
</span>		<span class="c1">// 但std::recursive_mutex提供这样的操作
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="c1">// 若std::lock成功获取了一个互斥量上的锁，并且尝试从另一个互斥量上再获取锁时抛出了异常
</span>		<span class="c1">// 那么第一个锁会随着异常的产生而自动释放，所以std::lock要么锁住两个锁，要么一个都不锁
</span>		<span class="c1">// 使用std::lock需要参数能够提供lock(),unlock(),try_lock()成员函数
</span>		<span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">);</span>

		<span class="c1">// 参数std::adopt_lock告诉std::lock_guard对象，互斥量已经被锁住了
</span>		<span class="c1">// 只需接收已存在的互斥量的锁定的所有权即可，不要试图构造时锁住它们
</span>		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_b</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">adopt_lock</span><span class="p">);</span>

		<span class="c1">// 如果非函数模板与函数模板提供同样好的匹配，则选择非模板版本
</span>		<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span> 
		<span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h3 id="advanced_guide_of_dead_lock">避免死锁的进阶指导</h3>

<p>死锁不仅存在于有锁的情况，当两个线程调用join相互等待时也能发生死锁。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个无mutex的死锁示例
</span><span class="kt">void</span> <span class="n">t2</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">t1</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">t2</span><span class="p">);</span>
	<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">t2</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="n">t</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">t1</span><span class="p">);</span>
	<span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<ul>
  <li><strong>尽量不要使用嵌套锁</strong>，因为这是造成死锁最常见的原因；如果一定要的话，使用<code class="highlighter-rouge">std::lock(mutexs)</code>；</li>
  <li><strong>尽量不要在持有锁的情况下调用用户代码</strong>，因为用户代码可能会获取锁，这样会造成嵌套锁；</li>
  <li>如果确实不能使用<code class="highlighter-rouge">std::lock(mutexs)</code>，那么最好在每个线程上<strong>使用固定的顺序获取锁</strong>。典型的如一个线程正在倒序访问双向链表，而另一个正在顺序访问，那么在中间部分就可能发生死锁；如果只能按顺序访问，那就不会出现死锁；</li>
  <li><strong>使用锁的层次结构</strong>。只能对比当前层次低(不包括等于)的互斥量上锁，这保证了锁的顺序性，且同一层不可能在同一时间持有两个锁，所以层级结构的互斥量是不可能产生死锁的。</li>
</ul>

<p>由于标准库并没有定义层次锁，所以需要自己定义<code class="highlighter-rouge">hierarchical_mutex</code>，为使其能够使用<code class="highlighter-rouge">std::lock_guard</code>模板，我们查看<code class="highlighter-rouge">std::lock_guard</code>的公有成员：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Mutex</span><span class="o">&gt;</span>
	<span class="k">class</span> <span class="nc">lock</span><span class="n">_guard</span><span class="o">&lt;</span><span class="n">_Mutex</span><span class="o">&gt;</span>
	<span class="p">{</span>	<span class="c1">// specialization for a single mutex
</span><span class="nl">public:</span>
	<span class="k">typedef</span> <span class="n">_Mutex</span> <span class="n">mutex_type</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">lock_guard</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">_MyMutex</span><span class="p">(</span><span class="n">_Mtx</span><span class="p">)</span>
		<span class="p">{</span>	<span class="c1">// construct and lock
</span>		<span class="n">_MyMutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
		<span class="p">}</span>

	<span class="n">lock_guard</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">adopt_lock_t</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">_MyMutex</span><span class="p">(</span><span class="n">_Mtx</span><span class="p">)</span>
		<span class="p">{</span>	<span class="c1">// construct but don't lock
</span>		<span class="p">}</span>

	<span class="o">~</span><span class="n">lock_guard</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
		<span class="p">{</span>	<span class="c1">// unlock
</span>		<span class="n">_MyMutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
		<span class="p">}</span>

	<span class="n">lock_guard</span><span class="p">(</span><span class="k">const</span> <span class="n">lock_guard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">lock_guard</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">lock_guard</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</code></pre>
</div>

<p>发现<strong>要想使用<code class="highlighter-rouge">std::lock_guard</code>模板，必须为模板参数提供<code class="highlighter-rouge">lock()</code>和<code class="highlighter-rouge">unlock()</code>成员，貌似并没有书中提到的<code class="highlighter-rouge">try_lock()</code>成员</strong>，下面是一个简单的层次锁实现：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个简单的层次锁实现
</span><span class="k">class</span> <span class="nc">hierarchical</span><span class="n">_mutex</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">internal_mutex</span><span class="p">;</span>

	<span class="c1">// 当前锁的层级值
</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">const</span> <span class="n">hierarchy_value</span><span class="p">;</span>

	<span class="c1">// 前一个锁的层级值，用以解锁后恢复原状态
</span>	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">previous_hierarchy_value</span><span class="p">;</span>

	<span class="c1">// 当前线程的层级值
</span>	<span class="c1">// thread_local 使得每个线程都有其独立的实例
</span>	<span class="k">static</span> <span class="n">thread_local</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">this_thread_hierarchy_value</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">check_for_hierarchy_violation</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">// 只能使用小于当前线程层级值的hierarchical_mutex
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">hierarchy_value</span> <span class="o">&gt;=</span> <span class="n">this_thread_hierarchy_value</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">"mutex hierarchy violated"</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">update_hierarchy_value</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">previous_hierarchy_value</span> <span class="o">=</span> <span class="n">this_thread_hierarchy_value</span><span class="p">;</span>
		<span class="n">this_thread_hierarchy_value</span> <span class="o">=</span> <span class="n">hierarchy_value</span><span class="p">;</span>
	<span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
	<span class="k">explicit</span> <span class="n">hierarchical_mutex</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">hierarchy_value</span><span class="p">(</span><span class="n">value</span><span class="p">),</span>
		<span class="n">previous_hierarchy_value</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="c1">// 不需要拷贝操作和默认构造函数
</span>	<span class="n">hierarchical_mutex</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="o">~</span><span class="n">hierarchical_mutex</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">hierarchical_mutex</span><span class="p">(</span><span class="k">const</span> <span class="n">hierarchical_mutex</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">hierarchical_mutex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">hierarchical_mutex</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">check_for_hierarchy_violation</span><span class="p">();</span>
		<span class="n">internal_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
		<span class="n">update_hierarchy_value</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">this_thread_hierarchy_value</span> <span class="o">=</span> <span class="n">previous_hierarchy_value</span><span class="p">;</span>
		<span class="n">internal_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="nf">try_lock</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">check_for_hierarchy_violation</span><span class="p">();</span>
		<span class="c1">// try_lock: 尝试lock互斥量，并立即返回，成功lock返回true
</span>		<span class="c1">// 如果另一个线程已经对该锁进行了lock，那么返回false
</span>		<span class="c1">// 如果该线程已经持有该互斥量，则调用try_lock行为未定义
</span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">internal_mutex</span><span class="p">.</span><span class="n">try_lock</span><span class="p">())</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">update_hierarchy_value</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 初始化为最大值是为了一开始任何层次锁都能被lock
</span><span class="n">thread_local</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">hierarchical_mutex</span><span class="o">::</span><span class="n">this_thread_hierarchy_value</span><span class="p">(</span><span class="n">ULONG_MAX</span><span class="p">);</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// hierarchical_mutex的简单使用
</span><span class="n">hierarchical_mutex</span> <span class="n">high_level_mutex</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="n">hierarchical_mutex</span> <span class="n">low_level_mutex</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">do_low_level_stuff</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">low_level_func</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">low_level_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_low_level_stuff</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">high_level_stuff</span><span class="p">(</span><span class="kt">int</span> <span class="n">some_param</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">high_level_func</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">high_level_mutex</span><span class="p">);</span>
	<span class="n">high_level_stuff</span><span class="p">(</span><span class="n">low_level_func</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// 正确，层次锁从高到低进行上锁
</span><span class="kt">void</span> <span class="nf">thread_a</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">high_level_func</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">hierarchical_mutex</span> <span class="n">other_mutex</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">do_other_stuff</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">other_stuff</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">high_level_func</span><span class="p">();</span>
	<span class="n">do_other_stuff</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// 异常！已lock的other_mutex的层次值比high_level_mutex低
</span><span class="kt">void</span> <span class="nf">thread_b</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">hierarchical_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">other_mutex</span><span class="p">);</span>	
	<span class="n">other_stuff</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="std_unique_lock">std::unique_lock</h3>

<p><code class="highlighter-rouge">std::unique_lock</code>比<code class="highlighter-rouge">std::lock_guard</code>更加灵活，查看几个常见的<code class="highlighter-rouge">std::unique_lock</code>公有成员：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 默认构造函数，不持有mutex
</span><span class="n">unique_lock</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="o">:</span> <span class="n">_Pmtx</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_Owns</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// default construct
</span>	<span class="p">}</span>
<span class="c1">// 成功lock后，持有该mutex
</span><span class="k">explicit</span> <span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">)</span>
	<span class="o">:</span> <span class="n">_Pmtx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_Mtx</span><span class="p">),</span> <span class="n">_Owns</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// construct and lock
</span>	<span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
	<span class="n">_Owns</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="c1">// 当第二个参数是std::adopt_lock时，_Mtx已经lock，并持有(own)该_Mtx
</span><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">adopt_lock_t</span><span class="p">)</span>
	<span class="o">:</span> <span class="n">_Pmtx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_Mtx</span><span class="p">),</span> <span class="n">_Owns</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// construct and assume already locked
</span>	<span class="p">}</span>
<span class="c1">// 当第二个参数是std::defer_lock时，_Mtx是unlock状态，但不持有(own)该_Mtx
</span><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">defer_lock_t</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="o">:</span> <span class="n">_Pmtx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_Mtx</span><span class="p">),</span> <span class="n">_Owns</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// construct but don't lock
</span>	<span class="p">}</span>
<span class="c1">// 当第二个参数是std::try_to_lock时，尝试lock该mutex，持有(own)与否取决于try_lock
</span><span class="n">unique_lock</span><span class="p">(</span><span class="n">_Mutex</span><span class="o">&amp;</span> <span class="n">_Mtx</span><span class="p">,</span> <span class="n">try_to_lock_t</span><span class="p">)</span>
	<span class="o">:</span> <span class="n">_Pmtx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_Mtx</span><span class="p">),</span> <span class="n">_Owns</span><span class="p">(</span><span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">try_lock</span><span class="p">())</span>
	<span class="p">{</span>	<span class="c1">// construct and try to lock
</span>	<span class="p">}</span>
<span class="c1">// 移动构造函数
</span><span class="n">unique_lock</span><span class="p">(</span><span class="n">unique_lock</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="o">:</span> <span class="n">_Pmtx</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span><span class="p">),</span> <span class="n">_Owns</span><span class="p">(</span><span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// destructive copy
</span>	<span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="c1">// 移动赋值运算符
</span><span class="n">unique_lock</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">unique_lock</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// destructive copy
</span>	<span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">_Other</span><span class="p">)</span>
		<span class="p">{</span>	<span class="c1">// different, move contents
</span>		<span class="k">if</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">)</span>
			<span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
		<span class="n">_Pmtx</span> <span class="o">=</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span><span class="p">;</span>
		<span class="n">_Owns</span> <span class="o">=</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span><span class="p">;</span>
		<span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>
<span class="c1">// 析构函数
</span><span class="o">~</span><span class="n">unique_lock</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// clean up
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">)</span>
		<span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="c1">// 拷贝操作不需要
</span><span class="n">unique_lock</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_lock</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">unique_lock</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_lock</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">lock</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// lock the mutex
</span>	<span class="n">_Validate</span><span class="p">();</span>
	<span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">();</span>
	<span class="n">_Owns</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

<span class="n">bool</span> <span class="nf">try_lock</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// try to lock the mutex
</span>	<span class="n">_Validate</span><span class="p">();</span>
	<span class="n">_Owns</span> <span class="o">=</span> <span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">try_lock</span><span class="p">();</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">);</span>
	<span class="p">}</span>

<span class="kt">void</span> <span class="nf">unlock</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// try to unlock the mutex
</span>	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_Pmtx</span> <span class="o">||</span> <span class="o">!</span><span class="n">_Owns</span><span class="p">)</span>
		<span class="n">_THROW_NCEE</span><span class="p">(</span><span class="n">system_error</span><span class="p">,</span>
			<span class="n">_STD</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">errc</span><span class="o">::</span><span class="n">operation_not_permitted</span><span class="p">));</span>

	<span class="n">_Pmtx</span><span class="o">-&gt;</span><span class="n">unlock</span><span class="p">();</span>
	<span class="n">_Owns</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>

<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">unique_lock</span><span class="o">&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// swap with _Other
</span>	<span class="n">_STD</span> <span class="n">swap</span><span class="p">(</span><span class="n">_Pmtx</span><span class="p">,</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Pmtx</span><span class="p">);</span>
	<span class="n">_STD</span> <span class="n">swap</span><span class="p">(</span><span class="n">_Owns</span><span class="p">,</span> <span class="n">_Other</span><span class="p">.</span><span class="n">_Owns</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Mutex</span> <span class="o">*</span><span class="n">release</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// disconnect
</span>	<span class="n">_Mutex</span> <span class="o">*</span><span class="n">_Res</span> <span class="o">=</span> <span class="n">_Pmtx</span><span class="p">;</span>
	<span class="n">_Pmtx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">_Owns</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">_Res</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">bool</span> <span class="n">owns_lock</span><span class="p">()</span> <span class="k">const</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if this object owns the lock
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">);</span>
	<span class="p">}</span>
<span class="c1">// 类型转换运算符
</span><span class="k">explicit</span> <span class="k">operator</span> <span class="n">bool</span><span class="p">()</span> <span class="k">const</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// return true if this object owns the lock
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Owns</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre>
</div>

<p>为了对<code class="highlighter-rouge">std::unique_lock</code>进行示例，修改<a href="#dead_lock">使用std::lock(mutex)的程序</a>如下：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 相比而言，std::unique_lock会占用比较多的空间，并且比std::lock_guard稍慢一些
</span><span class="k">class</span> <span class="nc">some</span><span class="n">_big_object</span><span class="p">;</span>
<span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">some_big_object</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="n">some_big_object</span> <span class="n">some_detail</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">X</span><span class="p">(</span><span class="n">some_big_object</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">sd</span><span class="p">)</span> <span class="o">:</span><span class="n">some_detail</span><span class="p">(</span><span class="n">sd</span><span class="p">)</span> <span class="p">{}</span>
	<span class="k">friend</span> <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lhs</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="c1">// 获取mutex，保持unlock状态，但不持有(own)它
</span>		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_a</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock_b</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">defer_lock</span><span class="p">);</span>

		<span class="c1">// 对获取的mutex进行lock，并持有(own)它
</span>		<span class="c1">// lock_a.lock();
</span>		<span class="c1">// lock_b.lock();
</span>
		<span class="c1">// 因为unique_lock能够提供lock(),unlock(),try_lock()成员函数
</span>		<span class="c1">// 所以能够使用std::lock
</span>		<span class="n">std</span><span class="o">::</span><span class="n">lock</span><span class="p">(</span><span class="n">lock_a</span><span class="p">,</span> <span class="n">lock_b</span><span class="p">);</span>

		<span class="c1">// 使用自定义函数进行数据交换
</span>		<span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>
		<span class="n">swap</span><span class="p">(</span><span class="n">lhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">some_detail</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h3 id="std_onceflag_and_callonce">std::once_flag,std::call_once</h3>

<p>如果数据初始化后锁住一个互斥量，纯粹是为了保护其初始化过程，那么这是没有必要的，并且这会给性能带来不必要的冲击。出于以上的原因，C++标准提供了一种纯粹保护共享数据初始化过程的机制。</p>

<p>很多单线程代码有类似下面的代码块，该代码块称为延迟初始化(Lazy initialization)：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// reset: 释放原有指针，并获取新指针
</span>		<span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>这种代码转到多线程时，可能会变成：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">resource_mutex</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 所有线程在此序列化，这是没必要的
</span>	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">resource_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource_ptr</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">// 只有初始化过程需要保护
</span>		<span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
	<span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>解决方案是使用C++标准库<code class="highlighter-rouge">std::once_flag</code>结构体和<code class="highlighter-rouge">std::call_once</code>模板：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">some_resource</span><span class="o">&gt;</span> <span class="n">resource_ptr</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">once_flag</span> <span class="n">resource_flag</span><span class="p">;</span> <span class="c1">// 和mutex一样，不可复制，也不可移动，只能默认初始化
</span>
<span class="kt">void</span> <span class="nf">init_resource</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">resource_ptr</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">some_resource</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 使用std::call_once比显式使用互斥量消耗更少资源(特别是当初始化完成后)
</span>	<span class="c1">// std::call_once可以和任何可调用对象一起使用
</span>	<span class="n">std</span><span class="o">::</span><span class="n">call_once</span><span class="p">(</span><span class="n">resource_flag</span><span class="p">,</span> <span class="n">init_resource</span><span class="p">);</span>
	<span class="n">resource_ptr</span><span class="o">-&gt;</span><span class="n">do_something</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>静态局部变量的初始化过程在多线程中可能会出现条件竞争(多个线程同时尝试对其进行初始化)，但C++11解决了这个问题：<strong>初始化及定义完全在一个线程中发生，并且没有其他线程可在初始化完成前对其进行处理，条件竞争终止于哪个线程来做这个初始化</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">class</span> <span class="nc">my</span><span class="n">_class</span><span class="p">;</span>

<span class="c1">// 多线程可以安全的调用get_my_class_instance()
</span><span class="n">my_class</span><span class="o">&amp;</span> <span class="n">get_my_class_instance</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="n">my_class</span> <span class="n">instance</span><span class="p">;</span>  <span class="c1">// 线程安全的初始化过程
</span>	<span class="k">return</span> <span class="n">instance</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="boost_shared_mutex">boost::shared_mutex</h3>

<p><strong>如果数据很长时间才更新一次的话，使用mutex会降低性能</strong>，因为大部分情况下都只是读取数据而非修改数据，这时<strong>可以使用<code class="highlighter-rouge">boost::shared_mutex</code>来优化同步性能</strong>。当数据进行更新操作时,可以使用<code class="highlighter-rouge">std::lock_guard&lt;boost::shared_mutex&gt;</code>或<code class="highlighter-rouge">std::unique_lock&lt;boost::shared_mutex&gt;</code>进行锁定,这能保证单独访问。这样做的唯一限制是：当一个线程尝试获取独占锁时，它需要等待其它拥有共享锁的线程解锁；当一个线程拥有独占锁时，其它线程不能获取独占锁或共享锁。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个使用boost::shared_mutex的示例
</span><span class="cp">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;mutex&gt;
#include &lt;boost/thread/shared_mutex.hpp&gt;
</span><span class="k">class</span> <span class="nc">dns</span><span class="n">_entry</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">dns</span><span class="n">_cache</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">dns_entry</span><span class="o">&gt;</span> <span class="n">entries</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="n">boost</span><span class="o">::</span><span class="n">shared_mutex</span> <span class="n">entry_mutex</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
	<span class="n">dns_entry</span> <span class="n">find_entry</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">)</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">boost</span><span class="o">::</span><span class="n">shared_lock</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">entry_mutex</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">dns_entry</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="k">const</span> <span class="n">it</span> <span class="o">=</span>
			<span class="n">entries</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">domain</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">it</span> <span class="o">==</span> <span class="n">entries</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">?</span> <span class="n">dns_entry</span><span class="p">()</span> <span class="o">:</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">update_or_add_entry</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">domain</span><span class="p">,</span>
		<span class="n">dns_entry</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">dns_details</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">shared_mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">entry_mutex</span><span class="p">);</span>
		<span class="n">entries</span><span class="p">[</span><span class="n">domain</span><span class="p">]</span> <span class="o">=</span> <span class="n">dns_details</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h2 id="synchronizing_thread">多线程同步</h2>

<p>在一个线程执行某些操作之前，可能需要等待另一个线程完成某些任务(如双目摄像头的图像获取显示)，这种情况就需要线程同步。<strong>C++标准库提供条件变量(condition variable)和期望(future)来处理线程同步问题</strong>。</p>

<p>当一个线程等待另一个线程完成任务时，可以有很多种方法：</p>

<ul>
  <li>持续检查共享数据标志(被mutex保护着)，直到另一线程完成工作时对这个标志进行重设。但这样会消耗不必要的时间检查，并且其它需要该mutex的线程会处于等待状态，消耗系统资源。</li>
  <li>在等待完成期间,使用<code class="highlighter-rouge">std::this_thread::sleep_for()</code>函数进行周期性的间歇。这样线程没有浪费执行时间，但是很难确定正确的休眠时间。</li>
  <li><strong>(最佳选择)使用C++标准库提供的工具去等待事件发生</strong>。等待一个事件被另一个线程触发最基本的工具是使用条件变量(condition variable)。从概念上讲，一个条件变量与某个条件相关联，并且一个或更多线程会等待那个条件的达成，当那个条件达成时，它会通知一个或多个在那个条件变量上等待的线程，唤醒它们，然后继续工作。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 周期间歇
</span><span class="n">bool</span> <span class="n">flag</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">wait_for_flag</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
		<span class="n">std</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span>
		<span class="n">lk</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="condition_variable">条件变量(condition variable)</h3>

<p>标准库提供两种条件变量的实现(<code class="highlighter-rouge">&lt;condition_variable&gt;</code>)：</p>

<ul>
  <li><code class="highlighter-rouge">std::condition_variable</code></li>
  <li><code class="highlighter-rouge">std::condition_variable_any</code></li>
</ul>

<p>为了进行合适的同步，它们都需要与一个mutex一起工作。但是<code class="highlighter-rouge">std::condition_variable</code>只能与<code class="highlighter-rouge">std::unique_lock&lt;std::mutex&gt;</code>一起使用，而<code class="highlighter-rouge">std::condition_variable_any</code>可以和任何满足最低标准(拥有lock和unlock成员函数)的锁一起工作，但是会有一些额外的开销。<strong>一般情况下，首选<code class="highlighter-rouge">std::condition_variable</code>，当对灵活性有需求时，才会使用<code class="highlighter-rouge">std::condition_variable_any</code></strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// condition_variable的简单使用
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;string&gt;
#include &lt;queue&gt;
#include &lt;condition_variable&gt;
</span>
<span class="c1">// 共享队列
</span><span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">data_queue</span><span class="p">;</span>

<span class="c1">// 锁住共享队列，并且与condition_variable相关联
</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mut</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">data_cond</span><span class="p">;</span>

<span class="c1">// 将每次输入打印在屏幕上，由于只有一个线程在使用std::cout，所以无需上锁
</span><span class="kt">void</span> <span class="nf">process</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 当输入字符串为quit时，结束线程
</span><span class="n">bool</span> <span class="nf">is_last_chunk</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">str</span> <span class="o">==</span> <span class="s">"quit"</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">data_preparation_thread</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
	<span class="c1">// 这里只有一个线程在使用std::cin，不用上锁
</span>	<span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="p">{</span>
			<span class="c1">// 在执行共享队列的修改操作时，需要上锁
</span>			<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
			<span class="n">data_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// 通知等待data_cond的线程，条件达成
</span>		<span class="n">data_cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_last_chunk</span><span class="p">(</span><span class="n">str</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">data_processing_thread</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> 
	<span class="p">{</span>
		<span class="c1">// 在等待条件变量时及数据弹出队列后，不需要对mut进行lock
</span>		<span class="c1">// 所以使用std::unique_lock对mut进行灵活的控制
</span>		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>

		<span class="c1">// wait(unique_lock&lt;mutex&gt;&amp;,_Predicate):接受一个unique_lock实例和一个bool型可调用对象(断言)
</span>		<span class="c1">// 若断言返回true，则wait立即返回，如果断言返回false，则wait会解锁传递的互斥量,并使线程阻塞
</span>		<span class="c1">// 当成员函数notify_one()被调用时，调用wait()的其中一个线程醒来，重新获取锁，并再次检查断言
</span>		<span class="c1">// 当成员函数notify_all()被调用时，调用wait()的所有线程醒来，重新获取锁，并再次检查断言
</span>		<span class="n">data_cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span>
			<span class="n">lk</span><span class="p">,</span> <span class="p">[]</span> <span class="p">{</span><span class="k">return</span> <span class="o">!</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>

		<span class="c1">// 弹出数据
</span>		<span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="n">lk</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

		<span class="c1">// 对弹出的数据进行操作
</span>		<span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_last_chunk</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t1</span><span class="p">(</span><span class="n">data_preparation_thread</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t2</span><span class="p">(</span><span class="n">data_processing_thread</span><span class="p">);</span>

	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果</p>

<div class="highlighter-rouge"><pre class="highlight"><code>kdjfa
kdjfa
quit
quit
</code></pre>
</div>

<h3 id="section-1">一个使用条件变量的简单线程安全队列</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个使用条件变量的简单线程安全队列
</span><span class="cp">#include &lt;queue&gt;
#include &lt;memory&gt;
#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">threadsafe</span><span class="n">_queue</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
	<span class="c1">// mutable：不管函数是否有const限定符，都可以对其进行修改
</span>	<span class="c1">// 由于empty()操作(const限定)需要对mut进行lock，但lock会修改mut的状态，所以标记为mutable
</span>	<span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mut</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">data_queue</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">data_cond</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">threadsafe_queue</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="o">~</span><span class="n">threadsafe_queue</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="c1">// 不允许拷贝赋值操作
</span>	<span class="n">threadsafe_queue</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">threadsafe_queue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">threadsafe_queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">T</span> <span class="n">new_value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
		<span class="n">data_queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">new_value</span><span class="p">);</span>
		<span class="n">data_cond</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">wait_and_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
		<span class="n">data_cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span><span class="k">return</span> <span class="o">!</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">wait_and_pop</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
		<span class="n">data_cond</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="k">this</span><span class="p">]</span> <span class="p">{</span><span class="k">return</span> <span class="o">!</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
		<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">()));</span>
		<span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="n">try_pop</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">value</span> <span class="o">=</span> <span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">try_pop</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data_queue</span><span class="p">.</span><span class="n">front</span><span class="p">()));</span>
		<span class="n">data_queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">mut</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">data_queue</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre>
</div>

<h3 id="future">期望(future)</h3>

<p><strong>C++标准库将一次性(one-off)事件称为期望(future)</strong>。当一个线程需要等待某个特定的一次性事件时，在某种程度上来说它应该知道这个事件在未来的表现形式。之后，这个线程会周期性的等待事件被触发，在等待期间也可以执行其他任务。例如，你要乘坐火车回家，你应该知道检票的时间和地点，在检票前，你可以做任何事，但是你可能会不断地查看时间、或简单的设个闹钟等待其触发。</p>

<p><strong>期望的事件发生后不能被重置</strong>。</p>

<p>C++标准库有两种类型的future模板实现(<code class="highlighter-rouge">&lt;future&gt;</code>)：</p>

<ul>
  <li><code class="highlighter-rouge">std::future&lt;&gt;</code>：独立期望(unique future);</li>
  <li><code class="highlighter-rouge">std::shared_future&lt;&gt;</code>：共享期望(shared future)。</li>
</ul>

<p><strong>一个<code class="highlighter-rouge">std::future</code>的实例是它关联事件的唯一实例；而多个<code class="highlighter-rouge">std::shared_future</code>实例却可以同时关联到同一个事件</strong>，这种情况下，所有实例会在同一时间变为ready状态，它们可以访问与事件相关的任何数据;</p>

<h3 id="std_future">std::future</h3>

<p>查看<code class="highlighter-rouge">std::future&lt;&gt;</code>的源代码：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 模板参数是关联数据的类型，void表示事件无关联数据。
</span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&amp;&gt;</span>
	<span class="o">:</span> <span class="k">public</span> <span class="n">_State_manager</span><span class="o">&lt;</span><span class="n">_Ty</span> <span class="o">*&gt;</span>
<span class="p">{</span>	<span class="c1">// class that defines a non-copyable asynchronous return object
</span>	<span class="c1">// that holds a reference
</span>	<span class="k">typedef</span> <span class="n">_State_manager</span><span class="o">&lt;</span><span class="n">_Ty</span> <span class="o">*&gt;</span> <span class="n">_Mybase</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">future</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// construct
</span>	<span class="p">}</span>

	<span class="n">future</span><span class="p">(</span><span class="n">future</span><span class="o">&amp;&amp;</span> <span class="n">_Other</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
		<span class="o">:</span> <span class="n">_Mybase</span><span class="p">(</span><span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Other</span><span class="p">),</span> <span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// construct from rvalue future object
</span>	<span class="p">}</span>

	<span class="n">future</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">future</span><span class="o">&amp;&amp;</span> <span class="n">_Right</span><span class="p">)</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// assign from rvalue future object
</span>		<span class="n">_Mybase</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">_STD</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&gt;</span><span class="p">(</span><span class="n">_Right</span><span class="p">));</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">future</span><span class="p">(</span><span class="k">const</span> <span class="n">_Mybase</span><span class="o">&amp;</span> <span class="n">_State</span><span class="p">,</span> <span class="n">_Nil</span><span class="p">)</span>
		<span class="o">:</span> <span class="n">_Mybase</span><span class="p">(</span><span class="n">_State</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// construct from associated asynchronous state object
</span>	<span class="p">}</span>

	<span class="o">~</span><span class="n">future</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// destroy
</span>	<span class="p">}</span>

	<span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// block until ready then return the stored result or
</span>		<span class="c1">// throw the stored exception
</span>		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_Get_value</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="n">shared_future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&amp;&gt;</span> <span class="n">share</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// return state as shared_future
</span>		<span class="k">return</span> <span class="p">(</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">_STD</span> <span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)));</span>
	<span class="p">}</span>

	<span class="c1">// 拷贝操作被删除
</span>	<span class="n">future</span><span class="p">(</span><span class="k">const</span> <span class="n">future</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">future</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">future</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<ul>
  <li>发现future的父类是<code class="highlighter-rouge">_State_manager</code>模板，<code class="highlighter-rouge">_State_manager</code>模板包含一些状态管理的操作；</li>
  <li><strong>一个非常有用的函数是<code class="highlighter-rouge">get()</code>函数，该函数阻塞直到future状态变为ready，然后返回结果</strong>；</li>
  <li><code class="highlighter-rouge">share()</code>成员函数转移当前<code class="highlighter-rouge">future</code>的所有权到一个<code class="highlighter-rouge">shared_future</code>，并将其返回；</li>
  <li>另外几个非常有用的wait系列函数来自<code class="highlighter-rouge">_State_manager</code>模板：
    <ul>
      <li><strong><code class="highlighter-rouge">wait()</code>函数阻塞直到结果变为有效(valid)</strong>；</li>
      <li><code class="highlighter-rouge">wait_for(time)</code>如果结果在指定时间内还不可用(valid)，那么会返回timeout；</li>
      <li><code class="highlighter-rouge">wait_until(timepoint)</code>如果到达指定时间点时结果还不可用(valid)，那么会返回timeout。</li>
    </ul>
  </li>
</ul>

<p><strong>期望类不提供同步访问</strong>，如果多个线程需要访问同一个期望实例，那么它们需要通过<a href="#sharing_data_between_threads">线程间共享数据</a>来保护访问。</p>

<p><strong>最基本的一次性(one-off)事件是有返回值的后台线程</strong>，但是<code class="highlighter-rouge">std::thread</code>并不提供直接接收返回值的机制，这里可以使用<code class="highlighter-rouge">std::async</code>函数模板(定义于<code class="highlighter-rouge">&lt;future&gt;</code>)。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个使用std::async的简单示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;string&gt;
</span>
<span class="kt">int</span> <span class="n">find_the_answer_to_ltuae</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&amp;</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">do_other_stuff</span><span class="p">();</span>

<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Y</span>
<span class="p">{</span>
	<span class="kt">double</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">double</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">move</span><span class="n">_only</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="n">move_only</span><span class="p">();</span>

	<span class="n">move_only</span><span class="p">(</span><span class="n">move_only</span><span class="o">&amp;&amp;</span><span class="p">);</span>
	<span class="n">move_only</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">move_only</span><span class="o">&amp;&amp;</span><span class="p">);</span>

	<span class="n">move_only</span><span class="p">(</span><span class="n">move_only</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">move_only</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">move_only</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

	<span class="kt">void</span> <span class="k">operator</span><span class="p">()();</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// std::async启动一个不需要立即获取结果的异步任务，参数传入与std::thread一样
</span>	<span class="c1">// 并返回一个std::future对象，这个对象最后持有函数的返回值
</span>	<span class="c1">// 对返回的future对象调用get()，线程阻塞直到future状态变为ready，然后返回结果
</span>	<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="kt">double</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">the_answer</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">find_the_answer_to_ltuae</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
	<span class="n">do_other_stuff</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The answer is "</span> <span class="o">&lt;&lt;</span> <span class="n">the_answer</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="n">X</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">foo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">);</span><span class="c1">// Calls p-&gt;foo(42,"hello") where p is &amp;x
</span>	<span class="k">auto</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">bar</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="s">"goodbye"</span><span class="p">);</span>   <span class="c1">// Calls tmpx.bar("goodbye") where tmpx is a copy of x
</span>
	<span class="n">Y</span> <span class="n">y</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">Y</span><span class="p">(),</span> <span class="mf">3.141</span><span class="p">);</span>              <span class="c1">// Calls tmpy(3.141) where tmpy is move-constructed from Y()
</span>	<span class="k">auto</span> <span class="n">f4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mf">2.718</span><span class="p">);</span>      <span class="c1">// Calls y(2.718)
</span>
	<span class="n">X</span> <span class="n">baz</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span><span class="p">);</span>                                     <span class="c1">// function declaration
</span>	<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">baz</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>                  <span class="c1">// Calls baz(x)
</span>
	<span class="k">auto</span> <span class="n">f5</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">move_only</span><span class="p">());</span>             <span class="c1">// Calls tmp() where tmp is constructed from std::move(move_only())
</span>
	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>你可以在调用<code class="highlighter-rouge">std::async</code>前传入一些额外的参数：</p>

<ul>
  <li><code class="highlighter-rouge">std::launch::deferred</code>：函数调用延迟直到成员函数<code class="highlighter-rouge">wait()</code>或<code class="highlighter-rouge">get()</code>被调用；</li>
  <li><code class="highlighter-rouge">std::launch::async</code>：函数必须在其自己的线程上运行；</li>
  <li><code class="highlighter-rouge">std::launch::deferred | std::launch::async</code>：默认参数，编译器自己选择。</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="k">auto</span> <span class="n">f6</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="n">Y</span><span class="p">(),</span> <span class="mf">1.2</span><span class="p">);</span>            <span class="c1">// Run in new thread
</span><span class="k">auto</span> <span class="n">f7</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span><span class="p">,</span> <span class="n">baz</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="c1">// Run in wait() or get()
</span><span class="k">auto</span> <span class="n">f8</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span>
	<span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">deferred</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span>
	<span class="n">baz</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>                                         <span class="c1">// Implementation chooses
</span><span class="k">auto</span> <span class="n">f9</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">baz</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>                        <span class="c1">// Implementation chooses
</span><span class="n">f7</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>                                                     <span class="c1">// 阻塞，直到结果有效(valid)
</span></code></pre>
</div>

<p><strong><code class="highlighter-rouge">std::async</code>使得算法可以被轻松的分成多个任务，然后同步执行(这在并行递归算法中非常有用)</strong>，但这不是任务关联到<code class="highlighter-rouge">std::future</code>的唯一方法。你还可以使用类模板<code class="highlighter-rouge">std::packaged_task</code>和<code class="highlighter-rouge">std::promise</code>。</p>

<h3 id="std_packaged_task">std::packaged_task</h3>

<p><code class="highlighter-rouge">std::packaged_task</code>绑定一个<code class="highlighter-rouge">future</code>到一个可调用对象。当<code class="highlighter-rouge">std::packaged_task</code>被调用时，它调用关联的可调用对象，使future变为ready状态，并存储返回值到这个future。</p>

<p><code class="highlighter-rouge">std::packaged_task</code>的模板参数是一个函数签名。例如，void表示无返回值无参数函数，<code class="highlighter-rouge">int(std::string&amp;,double*)</code>代表返回值为int，参数类型为<code class="highlighter-rouge">string&amp;,double*</code>。</p>

<p><strong>构造<code class="highlighter-rouge">std::packaged_task</code>实例时，必须传入一个函数或可调用对象，这个函数或可调用对象需要能接收指定的参数和返回可转换为指定返回类型的值</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个std::packaged_task特例化版本的局部定义
</span><span class="k">template</span><span class="o">&lt;&gt;</span>
<span class="k">class</span> <span class="nc">packaged</span><span class="n">_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;*</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
	<span class="c1">// 模板构造函数
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Callable</span><span class="o">&gt;</span>
	<span class="k">explicit</span> <span class="n">packaged_task</span><span class="p">(</span><span class="n">Callable</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>

	<span class="c1">// 函数签名返回类型指定get_future的返回类型
</span>	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_future</span><span class="p">();</span>

	<span class="c1">// 函数签名参数类型指定调用运算符的参数类型
</span>	<span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个使用std::packaged_task的简单示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;string&gt;
</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"void f1() called."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">f3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">str</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">double</span> <span class="n">f4</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task1</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task2</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task3</span><span class="p">(</span><span class="n">f3</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task4</span><span class="p">(</span><span class="n">f4</span><span class="p">);</span> <span class="c1">// 注意这里会有double到int的转换
</span>
	<span class="n">task1</span><span class="p">();</span>
	<span class="n">task2</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">(</span><span class="s">"hahahaha"</span><span class="p">);</span>
	<span class="n">task3</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>
	<span class="n">task4</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">task1</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">task2</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">future3</span> <span class="o">=</span> <span class="n">task3</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">future4</span> <span class="o">=</span> <span class="n">task4</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>

	<span class="c1">// wait感觉没什么软用，因为get包含了wait
</span>	<span class="n">future1</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
	<span class="n">future2</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
	<span class="n">future3</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
	<span class="n">future4</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">future2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
		<span class="o">&lt;&lt;</span> <span class="n">future3</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
		<span class="o">&lt;&lt;</span> <span class="n">future4</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>示例结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>void f1() called.
123
hahahaha
123
</code></pre>
</div>

<h3 id="std_promise">std::promise</h3>

<p><code class="highlighter-rouge">std::promise&lt;T&gt;</code>提供一种设置值(类型为T)的方法，这个值可以在设置之后被关联的<code class="highlighter-rouge">std::future&lt;T&gt;</code>对象读取。可以通过调用成员函数<code class="highlighter-rouge">get_future()</code>获取<code class="highlighter-rouge">std::promise&lt;T&gt;</code>关联的future。当promise通过成员函数<code class="highlighter-rouge">set_value()</code>设置完值后，关联的future状态变为ready，并可以通过其获取存储的值。如果promise没有设置值就被销毁了，那么关联的future会存储一个<code class="highlighter-rouge">std::future_errc::broken_promise</code>异常，该异常在调用get时会被重新抛出。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个使用std::promise的简单示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;string&gt;
</span>
<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pm1</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">pm2</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">thread1</span><span class="p">(){</span>
	<span class="n">pm1</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
	<span class="n">pm2</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="s">"hahah"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">thread2</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="n">future1</span> <span class="o">=</span> <span class="n">pm1</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">future2</span> <span class="o">=</span> <span class="n">pm2</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>

	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">future1</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
			  <span class="o">&lt;&lt;</span> <span class="n">future2</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// thread1设置数据，thread2获取数据
</span>	<span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">thread1</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">thread2</span><span class="p">);</span>
	
	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>示例结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>123
hahah
</code></pre>
</div>

<h3 id="save_exception_for_future">future存储异常</h3>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// future存储异常示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;exception&gt;
</span>
<span class="kt">double</span> <span class="nf">square_root</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"x&lt;0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">square_root</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="c1">// future调用get时，会将存储的异常重新抛出，不调用不会抛出
</span>		<span class="kt">double</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// std::packaged_task打包的函数抛出的异常也会被存储在关联的future中
</span>	<span class="n">try</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">square_root</span><span class="p">);</span>
		<span class="n">task</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">auto</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// std::promise可以使用set_exception成员函数设置一个异常到关联的future中
</span>	<span class="n">try</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pm</span><span class="p">;</span>
		<span class="n">pm</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span>
			<span class="c1">// boost::copy_exception
</span>			<span class="n">std</span><span class="o">::</span><span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">"my exception</span><span class="se">\n</span><span class="s">"</span><span class="p">))</span>
		<span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pm</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">// std::promise.set_exception通常用于set_value发生异常时使用
</span>	<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pm</span><span class="p">;</span>
	<span class="c1">// 一个线程设置值
</span>	<span class="n">try</span> <span class="p">{</span>
		<span class="n">pm</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
		<span class="c1">// std::current_exception: 当前异常
</span>		<span class="n">pm</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
	<span class="p">}</span>
	<span class="c1">// 一个线程获取值
</span>	<span class="n">try</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pm</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>示例结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>x&lt;0
x&lt;0
my exception
123
</code></pre>
</div>

<p>future存储异常的方式除了上面正常的方式外，<strong>如果<code class="highlighter-rouge">std::packaged_task</code>实例被调用前，或<code class="highlighter-rouge">std::promise</code>实例没有调用set系列函数前，其对象就销毁了，那么析构函数就会存储一个<code class="highlighter-rouge">std::future_errc::broken_promise</code>异常到其关联的future中</strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="o">~</span><span class="n">promise</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// destroy
</span>	<span class="k">if</span> <span class="p">(</span><span class="n">_MyPromise</span><span class="p">.</span><span class="n">_Is_valid</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_MyPromise</span><span class="p">.</span><span class="n">_Is_ready</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_MyPromise</span><span class="p">.</span><span class="n">_Is_ready_at_thread_exit</span><span class="p">())</span>
		<span class="p">{</span>	<span class="c1">// exception if destroyed before function object returns
</span>		<span class="n">future_error</span> <span class="n">_Fut</span><span class="p">(</span><span class="n">make_error_code</span><span class="p">(</span><span class="n">future_errc</span><span class="o">::</span><span class="n">broken_promise</span><span class="p">));</span>
		<span class="n">_MyPromise</span><span class="p">.</span><span class="n">_Get_state</span><span class="p">()</span>
			<span class="p">.</span><span class="n">_Set_exception</span><span class="p">(</span><span class="n">_STD</span> <span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">_Fut</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="o">~</span><span class="n">packaged_task</span><span class="p">()</span> <span class="n">_NOEXCEPT</span>
	<span class="p">{</span>	<span class="c1">// destroy
</span>	<span class="n">_MyPromise</span><span class="p">.</span><span class="n">_Get_state</span><span class="p">().</span><span class="n">_Abandon</span><span class="p">();</span>
	<span class="p">}</span>
<span class="kt">void</span> <span class="n">_Abandon</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// abandon shared state
</span>	<span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">_Lock</span><span class="p">(</span><span class="n">_Mtx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_Has_stored_result</span><span class="p">)</span>
		<span class="p">{</span>	<span class="c1">// queue exception
</span>		<span class="n">future_error</span> <span class="n">_Fut</span><span class="p">(</span><span class="n">make_error_code</span><span class="p">(</span><span class="n">future_errc</span><span class="o">::</span><span class="n">broken_promise</span><span class="p">));</span>
		<span class="n">_Set_exception_raw</span><span class="p">(</span><span class="n">_STD</span> <span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">_Fut</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">_Lock</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// future存储exception
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;exception&gt;
</span>
<span class="kt">double</span> <span class="n">square_root</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
		<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="p">(</span><span class="s">"x&lt;0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>	
	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">;</span>

	<span class="c1">// std::packaged_task销毁异常
</span>	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">(</span><span class="n">square_root</span><span class="p">);</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">// std::promise销毁异常
</span>	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">pm</span><span class="p">;</span>
		<span class="n">f</span> <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>示例结果(visual studio 2017):</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">broken</span> <span class="n">promise</span>
<span class="n">broken</span> <span class="n">promise</span>
</code></pre>
</div>

<h3 id="std_shared_future">std::shared_future</h3>

<p><strong><code class="highlighter-rouge">std::future</code>的局限性是只有一个线程能够获取等待结果，当有多个线程等待同一个事件时，可以使用<code class="highlighter-rouge">std::shared_future</code></strong>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// std::shared_future的简单示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;future&gt;
#include &lt;exception&gt;
</span>
<span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pm</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">cout_mut</span><span class="p">;</span>

<span class="c1">// future.share传递所有权到一个shared_future
// shared_future是可拷贝可移动的，各个拷贝会关联到同一个事件，获得同一个结果
</span><span class="n">std</span><span class="o">::</span><span class="n">shared_future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sf</span> <span class="o">=</span> <span class="n">pm</span><span class="p">.</span><span class="n">get_future</span><span class="p">().</span><span class="n">share</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">set_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">try</span> <span class="p">{</span>
		<span class="n">pm</span><span class="p">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pm</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">make_exception_ptr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process1</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="c1">// 拷贝sf而不是直接使用，这样能避免条件竞争
</span>	<span class="k">auto</span> <span class="n">sf1</span> <span class="o">=</span> <span class="n">sf</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sf1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lg</span><span class="p">(</span><span class="n">cout_mut</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"process1 value = "</span>
		<span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">process2</span><span class="p">()</span> 
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">sf2</span> <span class="o">=</span> <span class="n">sf</span><span class="p">;</span>
	<span class="k">auto</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sf2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>

	<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lg</span><span class="p">(</span><span class="n">cout_mut</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"process2 value = "</span>
		<span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">set_data</span><span class="p">,</span> <span class="mi">123</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">process1</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">process2</span><span class="p">);</span>

	<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">t3</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>示例结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>process1 value = 123
process2 value = 123
</code></pre>
</div>

<h2 id="wait_with_time_limit">限定等待时间</h2>

<p>之前的线程阻塞都是等待某一事件发生，这不能保证等待的时间，但在某些特定情况时，你需要等待固定的时间，或到达某个时间点，就不能再等了。你可以把等待的时间或时间点看做一个事件。C++标准库提供这样的功能，一般以<code class="highlighter-rouge">_for</code>结尾的等待函数等待固定时间，以<code class="highlighter-rouge">_until</code>结尾的等待函数等待特定的时间点，如<code class="highlighter-rouge">std::condition_variable</code>的<code class="highlighter-rouge">wait_for</code>和<code class="highlighter-rouge">wait_until</code>函数。</p>

<h3 id="clock">时钟(clock)</h3>

<p>对C++标准库来说，clock是时间信息源，其提供四种信息：</p>

<ul>
  <li>当前时间；</li>
  <li>用于表示clock包含的时间的值的类型，即时间值类型；</li>
  <li>时钟周期(tick period)；</li>
  <li>根据周期是否均匀，分为稳定(steady)时钟或不稳定时钟。</li>
</ul>

<p><strong>头文件<code class="highlighter-rouge">&lt;chrono&gt;</code>中有两种获取当前时间的函数：<code class="highlighter-rouge">std::chrono::steady_clock::now()</code>和<code class="highlighter-rouge">std::chrono::system_clock::now()</code>。其中<code class="highlighter-rouge">steady_clock</code>又被命名为<code class="highlighter-rouge">high_resolution_clock</code></strong>，不过老版本中是将<code class="highlighter-rouge">system_clock</code>命名为<code class="highlighter-rouge">high_resolution_clock</code>，至少vs2012是这样，所以在使用时，<strong>建议一致使用<code class="highlighter-rouge">high_resolution_clock</code></strong>。</p>

<p>时间值类型根据clock类型分为<code class="highlighter-rouge">chrono::time_point&lt;steady_clock&gt;</code>和<code class="highlighter-rouge">chrono::time_point&lt;system_clock&gt;</code>。</p>

<p><strong>时钟周期(tick period)被指定为一秒内tick的次数</strong>。如果一个clock一秒内tick 25次，那么它的周期就是<code class="highlighter-rouge">std::ratio&lt;1,25&gt;</code>；若5秒内tick两次，其周期就是<code class="highlighter-rouge">std::ratio&lt;5,2&gt;</code>。</p>

<p>如果时钟周期(tick period)均匀，且不可调整，则这个clock就是稳定(steady)的。<strong>可以根据常量静态成员变量<code class="highlighter-rouge">is_steady</code>来判断该clock类是否是steady的</strong>：如<code class="highlighter-rouge">system_clock</code>的<code class="highlighter-rouge">is_steady</code>等于false，<code class="highlighter-rouge">steady_clock</code>的<code class="highlighter-rouge">is_steady</code>等于true。</p>

<p><code class="highlighter-rouge">system_clock</code>表示系统的真实时间，该类还提供了<code class="highlighter-rouge">time_point</code>向<code class="highlighter-rouge">time_t</code>的类型转换成员函数<code class="highlighter-rouge">to_time_t</code>。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 获取当前时间的简单示例
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//auto now_steady = std::chrono::steady_clock::now();
</span>	<span class="k">auto</span> <span class="n">now_system</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	
	<span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">now_system</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// unsafe way
</span>
	<span class="c1">// safe way
</span>	<span class="cm">/*char buffer[26];
	ctime_s(buffer, 26, &amp;now);
	std::cout &lt;&lt; buffer &lt;&lt; std::endl;*/</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Tue May 16 10:38:23 2017
</code></pre>
</div>

<h3 id="duration">持续时间(duration)</h3>

<p>持续时间(duration)由<code class="highlighter-rouge">std::chrono::duration&lt;&gt;</code>模板进行处理，该模板的第一个模板参数为类型表示(int,long,double等)，第二个模板参数为每个持续时间(duration)单元代表的秒数。如<code class="highlighter-rouge">std::chrono::duration&lt;short, std::ratio&lt;60, 1&gt; &gt;</code>代表用short值存储分钟数，<code class="highlighter-rouge">std::chrono::duration&lt;double, std::ratio&lt;1, 1000&gt; &gt;</code>代表用double存储毫秒数。</p>

<p><code class="highlighter-rouge">&lt;chrono&gt;</code>头文件提供了一系列duration的预定义别名：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// SI TYPEDEFS
</span><span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000000000000000000LL</span><span class="o">&gt;</span> <span class="n">atto</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000000000000000LL</span><span class="o">&gt;</span> <span class="n">femto</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000000000000LL</span><span class="o">&gt;</span> <span class="n">pico</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000000000</span><span class="o">&gt;</span> <span class="n">nano</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000000</span><span class="o">&gt;</span> <span class="n">micro</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="o">&gt;</span> <span class="n">milli</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="o">&gt;</span> <span class="n">centi</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="o">&gt;</span> <span class="n">deci</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">deca</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">hecto</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">kilo</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1000000</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">mega</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1000000000</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">giga</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1000000000000LL</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">tera</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1000000000000000LL</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">peta</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">1000000000000000000LL</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">exa</span><span class="p">;</span>

<span class="c1">// duration TYPEDEFS
</span><span class="k">typedef</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">nano</span><span class="o">&gt;</span> <span class="n">nanoseconds</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">micro</span><span class="o">&gt;</span> <span class="n">microseconds</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="n">milli</span><span class="o">&gt;</span> <span class="n">milliseconds</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">seconds</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">60</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">minutes</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">duration</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">ratio</span><span class="o">&lt;</span><span class="mi">3600</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">hours</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>可以使用<code class="highlighter-rouge">std::chrono::duration_cast&lt;&gt;</code>显式转换不同类型的duration</strong>：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">(</span><span class="mi">54802</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span> <span class="n">s</span> <span class="o">=</span>
	<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">seconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span> <span class="c1">// 54
</span></code></pre>
</div>

<p>duration支持各种算数运算：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 获取单位时间的数量
</span><span class="n">constexpr</span> <span class="n">_Rep</span> <span class="n">count</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>	<span class="c1">// get stored rep
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_MyRep</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">constexpr</span> <span class="n">_Myt</span> <span class="k">operator</span><span class="o">+</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>	<span class="c1">// get value
</span>	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">constexpr</span> <span class="n">_Myt</span> <span class="k">operator</span><span class="o">-</span><span class="p">()</span> <span class="k">const</span>
	<span class="p">{</span>	<span class="c1">// get negated value
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Myt</span><span class="p">(</span><span class="mi">0</span> <span class="o">-</span> <span class="n">_MyRep</span><span class="p">));</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// increment rep
</span>	<span class="o">++</span><span class="n">_MyRep</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span> <span class="k">operator</span><span class="o">++</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// postincrement rep
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Myt</span><span class="p">(</span><span class="n">_MyRep</span><span class="o">++</span><span class="p">));</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">--</span><span class="p">()</span>
	<span class="p">{</span>	<span class="c1">// decrement rep
</span>	<span class="o">--</span><span class="n">_MyRep</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span> <span class="k">operator</span><span class="o">--</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// postdecrement rep
</span>	<span class="k">return</span> <span class="p">(</span><span class="n">_Myt</span><span class="p">(</span><span class="n">_MyRep</span><span class="o">--</span><span class="p">));</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">_Myt</span><span class="o">&amp;</span> <span class="n">_Right</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// add _Right to rep
</span>	<span class="n">_MyRep</span> <span class="o">+=</span> <span class="n">_Right</span><span class="p">.</span><span class="n">_MyRep</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">-=</span><span class="p">(</span><span class="k">const</span> <span class="n">_Myt</span><span class="o">&amp;</span> <span class="n">_Right</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// subtract _Right from rep
</span>	<span class="n">_MyRep</span> <span class="o">-=</span> <span class="n">_Right</span><span class="p">.</span><span class="n">_MyRep</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*=</span><span class="p">(</span><span class="k">const</span> <span class="n">_Rep</span><span class="o">&amp;</span> <span class="n">_Right</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// multiply rep by _Right
</span>	<span class="n">_MyRep</span> <span class="o">*=</span> <span class="n">_Right</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">/=</span><span class="p">(</span><span class="k">const</span> <span class="n">_Rep</span><span class="o">&amp;</span> <span class="n">_Right</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// divide rep by _Right
</span>	<span class="n">_MyRep</span> <span class="o">/=</span> <span class="n">_Right</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">%=</span><span class="p">(</span><span class="k">const</span> <span class="n">_Rep</span><span class="o">&amp;</span> <span class="n">_Right</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// modulus rep by _Right
</span>	<span class="n">_MyRep</span> <span class="o">%=</span> <span class="n">_Right</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

<span class="n">_Myt</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">%=</span><span class="p">(</span><span class="k">const</span> <span class="n">_Myt</span><span class="o">&amp;</span> <span class="n">_Right</span><span class="p">)</span>
	<span class="p">{</span>	<span class="c1">// modulus rep by _Right
</span>	<span class="n">_MyRep</span> <span class="o">%=</span> <span class="n">_Right</span><span class="p">.</span><span class="n">count</span><span class="p">();</span>
	<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre>
</div>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个基于持续时间的future等待
</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">some_task</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">wait_for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">35</span><span class="p">))</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">future_status</span><span class="o">::</span><span class="n">ready</span><span class="p">)</span>
	<span class="n">do_something_with</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</code></pre>
</div>

<h3 id="time_point">时间点(time point)</h3>

<p>时间点(time point)用<code class="highlighter-rouge">std::chrono::time_point&lt;&gt;</code>模板来表示，该模板的第一个模板参数指定clock的类型(<code class="highlighter-rouge">system_clock</code>或<code class="highlighter-rouge">steady_clock</code>)，第二个模板参数指定计量单位(<code class="highlighter-rouge">std::chrono::duration&lt;&gt;</code>)。一个时间点的值是从某个特定时间点开始的时间长度(指定计量单位的倍数)，这个特定时间点一般是<code class="highlighter-rouge">1970/1/1 08:00:00</code>，clock间可以共享这个特定时间点，也可以独立拥有。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 获取system_clock的epoch
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;chrono&gt;
#include &lt;ctime&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 方式一
</span>	<span class="k">auto</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="c1">// time_since_epoch获取从epoch开始直到time_point的时间长度
</span>	<span class="k">auto</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">time_point</span><span class="p">.</span><span class="n">time_since_epoch</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">time_epoch</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">time_point</span> <span class="o">-</span> <span class="n">duration</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time_epoch</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="c1">// 方式二
</span>	<span class="k">auto</span> <span class="n">tp_epoch</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">&gt;</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">epoch</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">to_time_t</span><span class="p">(</span><span class="n">tp_epoch</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ctime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epoch</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果(visual studio 2017):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>Thu Jan  1 08:00:00 1970

Thu Jan  1 08:00:00 1970

</code></pre>
</div>

<p><code class="highlighter-rouge">time_point</code>类可以进行各种算数操作，如<code class="highlighter-rouge">time_point - time_point</code>，<code class="highlighter-rouge">time_point - duration</code>等等。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个非常有用的计时操作
</span><span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="c1">//do_something();
</span><span class="k">auto</span> <span class="n">time_stop</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"took "</span> 
	<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_stop</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> 
	<span class="o">&lt;&lt;</span> <span class="s">" ms</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre>
</div>

<p><strong>推荐在写有时间限制的程序时，使用时间点进行等待</strong>，原因使用下列程序进行说明：</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;condition_variable&gt;
#include &lt;mutex&gt;
#include &lt;chrono&gt;
</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">cv</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">done</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

<span class="n">bool</span> <span class="nf">wait_loop</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 你也可以使用system_clock::from_time_t从time_t获取一个time_point
</span>	<span class="k">auto</span> <span class="k">const</span> <span class="n">timeout</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">+</span>
		<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span><span class="p">(</span><span class="mi">500</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="cm">/*
		If you use wait_for() in a loop, you might end up waiting almost the full length of time before
		a spurious wake, and the next time through the wait time starts again.This may repeatany number
		of times, making the total wait time unbounded
		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cv</span><span class="p">.</span><span class="n">wait_until</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="n">timeout</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">cv_status</span><span class="o">::</span><span class="n">timeout</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<h3 id="function_accept_timeouts">具有超时功能的函数</h3>

<p>一些常见的具有超时功能的函数：</p>

<table>
  <thead>
    <tr>
      <th>Class/Namespace</th>
      <th>Functions</th>
      <th>Return values</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="highlighter-rouge">std::this_thread</code></td>
      <td><code class="highlighter-rouge">sleep_for(duration)</code> <br /> <code class="highlighter-rouge">sleep_until(time_point)</code></td>
      <td>void</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">std::condition_variable</code> <br /> <code class="highlighter-rouge">std::condition_variable_any</code></td>
      <td><code class="highlighter-rouge">wait_for(lock, duration)</code> <br /> <code class="highlighter-rouge">wait_until(lock, time_point)</code></td>
      <td><code class="highlighter-rouge">std::cv_status::no_timeout</code> <br /> <code class="highlighter-rouge">std::cv_status::timeout</code></td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">std::condition_variable</code> <br /> <code class="highlighter-rouge">std::condition_variable_any</code></td>
      <td><code class="highlighter-rouge">wait_for(lock,duration,predicate)</code> <br /> <code class="highlighter-rouge">wait_until(lock,time_point,predicate)</code></td>
      <td>bool</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">std::timed_mutex</code> <br /> <code class="highlighter-rouge">std::recursive_timed_mutex</code></td>
      <td><code class="highlighter-rouge">try_lock_for(duration)</code> <br /> <code class="highlighter-rouge">try_lock_until(time_point)</code></td>
      <td>成功返回true</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">std::unique_lock&lt;TimedLockable&gt;</code></td>
      <td><code class="highlighter-rouge">unique_lock(lockable,duration)</code> <br /> <code class="highlighter-rouge">unique_lock(lockable,time_point)</code></td>
      <td>构造函数</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">std::unique_lock&lt;TimedLockable&gt;</code></td>
      <td><code class="highlighter-rouge">try_lock_for(duration)</code> <br /> <code class="highlighter-rouge">try_lock_until(time_point)</code></td>
      <td>成功返回true</td>
    </tr>
    <tr>
      <td><code class="highlighter-rouge">std::future&lt;ValueType&gt;</code> <br /> <code class="highlighter-rouge">std::shared_future&lt;ValueType&gt;</code></td>
      <td><code class="highlighter-rouge">wait_for(duration)</code> <br /> <code class="highlighter-rouge">wait_until(time_point)</code></td>
      <td><code class="highlighter-rouge">std::future_status::ready</code> <br /> <code class="highlighter-rouge">std::future_status::timeout</code> <br /> <code class="highlighter-rouge">std::future_status::deferred</code></td>
    </tr>
  </tbody>
</table>

<h2 id="simplify_code_with_synchronization">使用同步操作简化代码</h2>

<h3 id="functional_program_with_future">使用future的函数化编程(functional programming)</h3>

<p><strong>函数化编程(functional programming)是指一个函数调用的结果只依赖于传入的参数，而与其它外部状态无关。这意味着如果你用相同的参数对同一个函数调用两次的结果肯定是一样的</strong>。</p>

<p>future使得函数化编程模式在C++中变得可以并行运行，future可以在线程间传递，并且允许一个结果依赖于另一个结果，而不用显式访问共享数据。</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="c1">// 一个简单的例子
</span><span class="cp">#include &lt;iostream&gt;
#include &lt;cstdlib&gt;
#include &lt;list&gt;
#include &lt;algorithm&gt;
#include &lt;future&gt;
#include &lt;iterator&gt;
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="c1">// l.splice(iterator pos,list&amp; x, iterator i)
</span>	<span class="c1">// 将x中i指向的元素移动插入到l中pos指向的位置之前
</span>	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
	<span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pivot</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

	<span class="c1">// std::partition(iterator beg, iterator end, func)
</span>	<span class="c1">// 将[beg,end)中的元素按func分为两组，第一组使func返回true，第二组使func返回false
</span>	<span class="c1">// 返回分组后指向第二组的第一个元素的迭代器，不保证原有元素的顺序
</span>	<span class="k">auto</span> <span class="n">divide_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
		<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">pivot</span><span class="p">;</span> <span class="p">});</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lower_part</span><span class="p">;</span>
	<span class="c1">// l.splice(iterator pos,list&amp; x, iterator beg, iterator end)
</span>	<span class="c1">// 将x中[beg,end)范围内元素移动插入到l中pos指向的位置之前
</span>	<span class="n">lower_part</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lower_part</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">divide_point</span><span class="p">);</span>

	<span class="k">auto</span> <span class="n">new_lower</span><span class="p">(</span>
		<span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lower_part</span><span class="p">)));</span>
	<span class="k">auto</span> <span class="n">new_higher</span><span class="p">(</span>
		<span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">input</span><span class="p">)));</span>

	<span class="c1">// l.splice(iterator pos,list&amp; x)
</span>	<span class="c1">// 将x中所有元素移动插入到l中pos指向的位置之前
</span>	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">new_higher</span><span class="p">);</span>
	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_lower</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">input</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">input</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
	<span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pivot</span> <span class="o">=</span> <span class="o">*</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

	<span class="k">auto</span> <span class="n">divide_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">input</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
		<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">t</span><span class="o">&lt;</span><span class="n">pivot</span><span class="p">;</span> <span class="p">});</span>

	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">lower_part</span><span class="p">;</span>
	<span class="n">lower_part</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">lower_part</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">input</span><span class="p">,</span> <span class="n">input</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">divide_point</span><span class="p">);</span>

	<span class="c1">// 小于pivot的元素在新线程中运行，任务数按递归次数呈指数增长
</span>	<span class="c1">// 当任务数太多时，这些任务会在调用get()的线程上运行而不是开启一个新线程
</span>	<span class="c1">// 这是因为async的默认参数std::launch::deferred | std::launch::async会自动切换
</span>	<span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">new_lower</span><span class="p">(</span>
		<span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parallel_quick_sort</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">lower_part</span><span class="p">)));</span>

	<span class="k">auto</span> <span class="n">new_higher</span><span class="p">(</span>
		<span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">input</span><span class="p">)));</span>

	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">new_higher</span><span class="p">);</span>
	<span class="n">result</span><span class="p">.</span><span class="n">splice</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">new_lower</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">// 顺序版
</span>	<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">{</span> <span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span> <span class="p">};</span>
	<span class="k">auto</span> <span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sequential_quick_sort</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="k">auto</span> <span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sequential_quick_sort took "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span>
		<span class="o">&lt;&lt;</span> <span class="s">"ms.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">ostream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">out</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">,</span> <span class="s">" "</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">out</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="c1">// 并发版
</span>	<span class="n">time_start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">res</span> <span class="o">=</span> <span class="n">parallel_quick_sort</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="n">time_end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"parallel_quick_sort took "</span>
		<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">milli</span><span class="o">&gt;</span><span class="p">(</span><span class="n">time_end</span> <span class="o">-</span> <span class="n">time_start</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> 
		<span class="o">&lt;&lt;</span> <span class="s">"ms.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

	<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cbegin</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cend</span><span class="p">(</span><span class="n">res</span><span class="p">),</span> <span class="n">out</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="n">getchar</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>结果：</p>

<div class="highlighter-rouge"><pre class="highlight"><code>sequential_quick_sort took 1.08664ms.
1 2 3 4 5 6 7
parallel_quick_sort took 1.57094ms.
1 2 3 4 5 6 7
</code></pre>
</div>

<h3 id="synchronize_operations_with_message_passing">状态机</h3>

<p><strong>CSP(Communicating Sequential Processes)：当没有共享数据，每个线程就可以进行独立思考，其行为纯粹基于其所接收到的信息，这样每个线程就相当于一个状态机</strong>。</p>

<p>ATM机作为一个典型的状态机模型，下面就来做一个简单的实现。</p>

<h4 id="header_atm_h">ATM.h</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#ifndef _ATM_H_
#define _ATM_H_
</span>
<span class="cp">#include &lt;mutex&gt;
#include &lt;condition_variable&gt;
#include &lt;queue&gt;
#include &lt;memory&gt;
#include &lt;iostream&gt;
</span>
<span class="k">namespace</span> <span class="n">messaging</span>
<span class="p">{</span>
	<span class="c1">// 邮件基类
</span>	<span class="k">struct</span> <span class="n">message_base</span>
	<span class="p">{</span>
		<span class="k">virtual</span> <span class="o">~</span><span class="n">message_base</span><span class="p">()</span>
		<span class="p">{}</span>
	<span class="p">};</span>

	<span class="c1">// 每种邮件有自己的类型，由模板参数Msg指定
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Msg</span><span class="o">&gt;</span>
	<span class="k">struct</span> <span class="n">wrapped_message</span> <span class="o">:</span> <span class="n">message_base</span>
	<span class="p">{</span>
		<span class="n">Msg</span> <span class="n">contents</span><span class="p">;</span>
		<span class="k">explicit</span> <span class="nf">wrapped_message</span><span class="p">(</span><span class="n">Msg</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">contents_</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">contents</span><span class="p">(</span><span class="n">contents_</span><span class="p">)</span>
		<span class="p">{}</span>
	<span class="p">};</span>

	<span class="c1">// 邮箱
</span>	<span class="k">class</span> <span class="nc">queue</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">c</span><span class="p">;</span>
		<span class="c1">// 标准库队列存储着邮件基类的智能指针
</span>		<span class="c1">// 指向派生类的基类的指针可以使用dynamic_cast转换回派生类指针
</span>		<span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">message_base</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>

	<span class="k">public</span><span class="o">:</span>

		<span class="n">queue</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

		<span class="c1">// 不需要拷贝操作
</span>		<span class="n">queue</span><span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
		<span class="n">queue</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">queue</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
		<span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="c1">// 压入派生类的智能指针
</span>			<span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">wrapped_message</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">));</span>
			<span class="n">c</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">message_base</span><span class="o">&gt;</span> <span class="n">wait_and_pop</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
			<span class="c1">// 阻塞等待，直到q不为空
</span>			<span class="n">c</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span><span class="k">return</span> <span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span> <span class="p">});</span>
			<span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
			<span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">res</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="c1">// 关闭的邮箱，如果你收到它里面的邮件，你会遇到鬼(发生异常)
</span>	<span class="k">class</span> <span class="nc">close</span><span class="n">_queue</span>
	<span class="p">{};</span>

	<span class="c1">// 邮递员模板
</span>	<span class="c1">// PreviousDispatcher: 上一个邮递员(交接)
</span>	<span class="c1">// Msg: 该邮递员能处理的邮件类型
</span>	<span class="c1">// Func: 该邮递员处理该邮件的方式
</span>	<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">PreviousDispatcher</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Msg</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
	<span class="k">class</span> <span class="nc">TemplateDispatcher</span>
	<span class="p">{</span>
		<span class="n">queue</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>                  <span class="c1">// 管理的邮箱地址
</span>		<span class="n">PreviousDispatcher</span><span class="o">*</span> <span class="n">prev</span><span class="p">;</span>  <span class="c1">// 上一个邮递员的地址
</span>		<span class="n">Func</span> <span class="n">f</span><span class="p">;</span>                    <span class="c1">// 该邮递员处理该邮件的方式
</span>		<span class="n">bool</span> <span class="n">chained</span><span class="p">;</span>              <span class="c1">// 该邮递员是否离职        
</span>
								   <span class="c1">// 不需要拷贝操作
</span>		<span class="n">TemplateDispatcher</span><span class="p">(</span><span class="n">TemplateDispatcher</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
		<span class="n">TemplateDispatcher</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TemplateDispatcher</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

		<span class="c1">// 邮递员间都是朋友，需要帮助的时候可以相互照应
</span>		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Dispatcher</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OtherMsg</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OtherFunc</span><span class="o">&gt;</span>
		<span class="k">friend</span> <span class="k">class</span> <span class="nc">TemplateDispatcher</span><span class="p">;</span>

		<span class="c1">// 邮递员等待邮箱邮件，然后派件
</span>		<span class="kt">void</span> <span class="nf">wait_and_dispatch</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(;;)</span>
			<span class="p">{</span>
				<span class="k">auto</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_and_pop</span><span class="p">();</span>
				<span class="c1">// 如果该邮递员能够处理这个邮件，那么他需要外出处理这次派件
</span>				<span class="c1">// 如果该邮件不能处理，那么该邮件会被丢弃
</span>				<span class="k">if</span> <span class="p">(</span><span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// 邮递员派件
</span>		<span class="n">bool</span> <span class="nf">dispatch</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">message_base</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 检查该邮件类型是否是自己能处理的邮件类型
</span>			<span class="c1">// 若是，则按照往常的方式处理该邮件
</span>			<span class="c1">// 若不是，该邮递员处理不了这个邮件，向上一个邮递员求助
</span>			<span class="k">if</span> <span class="p">(</span><span class="n">wrapped_message</span><span class="o">&lt;</span><span class="n">Msg</span><span class="o">&gt;*</span> <span class="n">wrapper</span> <span class="o">=</span>
				<span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">wrapped_message</span><span class="o">&lt;</span><span class="n">Msg</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span>
			<span class="p">{</span>
				<span class="n">f</span><span class="p">(</span><span class="n">wrapper</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span>
			<span class="p">{</span>
				<span class="k">return</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

	<span class="k">public</span><span class="o">:</span>

		<span class="c1">// 移动构造函数，邮递员other不干了，将任务全部交给下一个人
</span>		<span class="n">TemplateDispatcher</span><span class="p">(</span><span class="n">TemplateDispatcher</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">q</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">q</span><span class="p">),</span>
			<span class="n">prev</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">prev</span><span class="p">),</span>
			<span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">f</span><span class="p">)),</span>
			<span class="n">chained</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">chained</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">other</span><span class="p">.</span><span class="n">chained</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// 新官上任，prev_进行交接
</span>		<span class="n">TemplateDispatcher</span><span class="p">(</span><span class="n">queue</span><span class="o">*</span> <span class="n">q_</span><span class="p">,</span> <span class="n">PreviousDispatcher</span><span class="o">*</span> <span class="n">prev_</span><span class="p">,</span> <span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">f_</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">q</span><span class="p">(</span><span class="n">q_</span><span class="p">),</span>
			<span class="n">prev</span><span class="p">(</span><span class="n">prev_</span><span class="p">),</span>
			<span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f_</span><span class="p">)),</span>
			<span class="n">chained</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">prev_</span><span class="o">-&gt;</span><span class="n">chained</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// 该邮递员有权利将管理的邮箱的邮件交给临时工派件
</span>		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">OtherMsg</span><span class="p">,</span> <span class="k">typename</span> <span class="n">OtherFunc</span><span class="o">&gt;</span>
		<span class="n">TemplateDispatcher</span><span class="o">&lt;</span><span class="n">TemplateDispatcher</span><span class="p">,</span> <span class="n">OtherMsg</span><span class="p">,</span> <span class="n">OtherFunc</span><span class="o">&gt;</span>
			<span class="n">handle</span><span class="p">(</span><span class="n">OtherFunc</span><span class="o">&amp;&amp;</span> <span class="n">of</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 临时对象返回时会进行析构，析构时会进行一次派件任务			
</span>			<span class="k">return</span> <span class="n">TemplateDispatcher</span><span class="o">&lt;</span>
				<span class="n">TemplateDispatcher</span><span class="p">,</span> <span class="n">OtherMsg</span><span class="p">,</span> <span class="n">OtherFunc</span><span class="o">&gt;</span><span class="p">(</span>
					<span class="n">q</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">OtherFunc</span><span class="o">&gt;</span><span class="p">(</span><span class="n">of</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="c1">// noexcept(false)：可以抛出异常
</span>		<span class="o">~</span><span class="n">TemplateDispatcher</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 若未离职，则至少需要完成一次派件
</span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chained</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">wait_and_dispatch</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="c1">// 邮件验收者
</span>	<span class="k">class</span> <span class="nc">dispatcher</span>
	<span class="p">{</span>
		<span class="n">queue</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">chained</span><span class="p">;</span>

		<span class="c1">// 不需要拷贝操作
</span>		<span class="n">dispatcher</span><span class="p">(</span><span class="n">dispatcher</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
		<span class="n">dispatcher</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">dispatcher</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

		<span class="c1">// 邮件验收者和邮递员都是朋友
</span>		<span class="k">template</span><span class="o">&lt;</span>
			<span class="k">typename</span> <span class="n">Dispatcher</span><span class="p">,</span>
			<span class="k">typename</span> <span class="n">Msg</span><span class="p">,</span>
			<span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
			<span class="k">friend</span> <span class="k">class</span> <span class="nc">TemplateDispatcher</span><span class="p">;</span>

		<span class="kt">void</span> <span class="nf">wait_and_dispatch</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(;;)</span>
			<span class="p">{</span>
				<span class="k">auto</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">wait_and_pop</span><span class="p">();</span>
				<span class="n">dispatch</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// 邮件验收者确认邮件是不是属于已关闭的邮箱
</span>		<span class="c1">// 该函数会在邮递员处理不了某一邮件时被调用
</span>		<span class="n">bool</span> <span class="nf">dispatch</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">message_base</span><span class="o">&gt;</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">wrapped_message</span><span class="o">&lt;</span><span class="n">close_queue</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span>
			<span class="p">{</span>
				<span class="k">throw</span> <span class="n">close_queue</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="k">public</span><span class="o">:</span>

		<span class="c1">// 邮件验收者不干了(移动构造函数)
</span>		<span class="n">dispatcher</span><span class="p">(</span><span class="n">dispatcher</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">q</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">q</span><span class="p">),</span>
			<span class="n">chained</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">chained</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">other</span><span class="p">.</span><span class="n">chained</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// 新官上任
</span>		<span class="k">explicit</span> <span class="n">dispatcher</span><span class="p">(</span><span class="n">queue</span><span class="o">*</span> <span class="n">q_</span><span class="p">)</span> <span class="o">:</span>
			<span class="n">q</span><span class="p">(</span><span class="n">q_</span><span class="p">),</span>
			<span class="n">chained</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
		<span class="p">{}</span>

		<span class="c1">// 邮件验收者处理邮件的方式就是交给相应的邮递员去派件
</span>		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Message</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Func</span><span class="o">&gt;</span>
		<span class="n">TemplateDispatcher</span><span class="o">&lt;</span><span class="n">dispatcher</span><span class="p">,</span> <span class="n">Message</span><span class="p">,</span> <span class="n">Func</span><span class="o">&gt;</span>
			<span class="n">handle</span><span class="p">(</span><span class="n">Func</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">TemplateDispatcher</span><span class="o">&lt;</span><span class="n">dispatcher</span><span class="p">,</span> <span class="n">Message</span><span class="p">,</span> <span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="n">q</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Func</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="c1">// 邮件验收者也需要至少验收一次派件
</span>		<span class="o">~</span><span class="n">dispatcher</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">chained</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">wait_and_dispatch</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="c1">// 邮件发送者
</span>	<span class="k">class</span> <span class="nc">sender</span>
	<span class="p">{</span>
		<span class="n">queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span> <span class="c1">// 该邮件发送者寄送邮件邮箱地址
</span>
	<span class="k">public</span><span class="o">:</span>

		<span class="c1">// 邮件发送者小白并不知道邮箱地址
</span>		<span class="n">sender</span><span class="p">()</span> <span class="o">:</span> <span class="n">q</span><span class="p">(</span><span class="n">nullptr</span><span class="p">)</span>
		<span class="p">{}</span>

		<span class="c1">// 邮件发送者长者自带一个邮箱地址
</span>		<span class="k">explicit</span> <span class="n">sender</span><span class="p">(</span><span class="n">queue</span> <span class="o">*</span><span class="n">q_</span><span class="p">)</span> <span class="o">:</span> <span class="n">q</span><span class="p">(</span><span class="n">q_</span><span class="p">)</span>
		<span class="p">{}</span>

		<span class="c1">// 发送邮件，将邮件投入邮箱即可
</span>		<span class="c1">// 拷贝操作是允许的，给小白留了一条活路
</span>		<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Message</span><span class="o">&gt;</span>
		<span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="n">Message</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">q</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">};</span>

	<span class="c1">// 邮件接收人
</span>	<span class="k">class</span> <span class="nc">receiver</span>
	<span class="p">{</span>
		<span class="n">queue</span> <span class="n">q</span><span class="p">;</span> <span class="c1">// 邮件接收人拥有一个专属的邮箱
</span>
	<span class="k">public</span><span class="o">:</span>

		<span class="c1">// 类型转换运算符
</span>		<span class="c1">// 邮件接收人可以转换成邮件发送者进行回信
</span>		<span class="k">operator</span> <span class="n">sender</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">sender</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// 等待邮件验收者验收邮件
</span>		<span class="n">dispatcher</span> <span class="n">wait</span><span class="p">()</span>
		<span class="p">{</span>
			<span class="k">return</span> <span class="n">dispatcher</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">};</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">withdraw</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atm_queue</span><span class="p">;</span>

	<span class="n">withdraw</span><span class="p">(</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">account_</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">,</span>
		<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atm_queue_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">account</span><span class="p">(</span><span class="n">account_</span><span class="p">),</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">),</span>
		<span class="n">atm_queue</span><span class="p">(</span><span class="n">atm_queue_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">withdraw_ok</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">withdraw_denied</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">cancel_withdrawal</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>

	<span class="n">cancel_withdrawal</span><span class="p">(</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">account_</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">account</span><span class="p">(</span><span class="n">account_</span><span class="p">),</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">withdrawal_processed</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>

	<span class="n">withdrawal_processed</span><span class="p">(</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">account_</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">account</span><span class="p">(</span><span class="n">account_</span><span class="p">),</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">)</span>
	<span class="p">{}</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="n">card_inserted</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">card_inserted</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">account_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">account</span><span class="p">(</span><span class="n">account_</span><span class="p">)</span>
	<span class="p">{}</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="n">digit_pressed</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">digit</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">digit_pressed</span><span class="p">(</span><span class="kt">char</span> <span class="n">digit_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">digit</span><span class="p">(</span><span class="n">digit_</span><span class="p">)</span>
	<span class="p">{}</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="n">clear_last_pressed</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">eject_card</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">withdraw_pressed</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">withdraw_pressed</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">)</span>
	<span class="p">{}</span>

<span class="p">};</span>

<span class="k">struct</span> <span class="n">cancel_pressed</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">issue_money</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>

	<span class="n">issue_money</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">verify_pin</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pin</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atm_queue</span><span class="p">;</span>

	<span class="n">verify_pin</span><span class="p">(</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">account_</span><span class="p">,</span>
		<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">pin_</span><span class="p">,</span>
		<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atm_queue_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">account</span><span class="p">(</span><span class="n">account_</span><span class="p">),</span>
		<span class="n">pin</span><span class="p">(</span><span class="n">pin_</span><span class="p">),</span>
		<span class="n">atm_queue</span><span class="p">(</span><span class="n">atm_queue_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">pin_verified</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">pin_incorrect</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">display_enter_pin</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">display_enter_card</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">display_insufficient_funds</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">display_withdrawal_cancelled</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">display_pin_incorrect_message</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">display_withdrawal_options</span>
<span class="p">{};</span>

<span class="k">struct</span> <span class="n">get_balance</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>
	<span class="k">mutable</span> <span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atm_queue</span><span class="p">;</span>

	<span class="n">get_balance</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">account_</span><span class="p">,</span> <span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atm_queue_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">account</span><span class="p">(</span><span class="n">account_</span><span class="p">),</span>
		<span class="n">atm_queue</span><span class="p">(</span><span class="n">atm_queue_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">balance</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">balance</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">display_balance</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">amount</span><span class="p">;</span>

	<span class="k">explicit</span> <span class="nf">display_balance</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">amount_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">amount</span><span class="p">(</span><span class="n">amount_</span><span class="p">)</span>
	<span class="p">{}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">balance_pressed</span>
<span class="p">{};</span>

<span class="c1">// ATM逻辑业务状态机，从run函数开始看
</span><span class="k">class</span> <span class="nc">atm</span>
<span class="p">{</span>
	<span class="n">messaging</span><span class="o">::</span><span class="n">receiver</span> <span class="n">incoming</span><span class="p">;</span>          <span class="c1">// 邮件接收人
</span>	<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">bank</span><span class="p">;</span>                <span class="c1">// 邮件发送者1--银行
</span>	<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">interface_hardware</span><span class="p">;</span>  <span class="c1">// 邮件发送者2--人机交互界面
</span>	<span class="kt">void</span> <span class="p">(</span><span class="n">atm</span><span class="o">::*</span><span class="n">state</span><span class="p">)();</span>                  <span class="c1">// atm机状态
</span>	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">account</span><span class="p">;</span>                   <span class="c1">// 用户账户
</span>	<span class="kt">unsigned</span> <span class="n">withdrawal_amount</span><span class="p">;</span>            <span class="c1">// 取款金额
</span>	<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pin</span><span class="p">;</span>                       <span class="c1">// 账户密码
</span>
	<span class="kt">void</span> <span class="nf">process_withdrawal</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">withdraw_ok</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">withdraw_ok</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
				<span class="n">issue_money</span><span class="p">(</span><span class="n">withdrawal_amount</span><span class="p">));</span>

			<span class="n">bank</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
				<span class="n">withdrawal_processed</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">withdrawal_amount</span><span class="p">));</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">wait_for_action</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">withdraw_denied</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">withdraw_denied</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 余额不足
</span>			<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">display_insufficient_funds</span><span class="p">());</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">wait_for_action</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">cancel_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cancel_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">bank</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
				<span class="n">cancel_withdrawal</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">withdrawal_amount</span><span class="p">));</span>

			<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
				<span class="n">display_withdrawal_cancelled</span><span class="p">());</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">done_processing</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">process_balance</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">balance</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">balance</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">display_balance</span><span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">amount</span><span class="p">));</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">wait_for_action</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">cancel_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cancel_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">done_processing</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">wait_for_action</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">display_withdrawal_options</span><span class="p">());</span>

		<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">withdraw_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">withdraw_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">withdrawal_amount</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">amount</span><span class="p">;</span>

			<span class="c1">// 提款
</span>			<span class="n">bank</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">withdraw</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">msg</span><span class="p">.</span><span class="n">amount</span><span class="p">,</span> <span class="n">incoming</span><span class="p">));</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">process_withdrawal</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">balance_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">balance_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// 获取余额
</span>			<span class="n">bank</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">get_balance</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">incoming</span><span class="p">));</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">process_balance</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">cancel_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cancel_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">done_processing</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">verifying_pin</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">pin_verified</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">pin_verified</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">wait_for_action</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">pin_incorrect</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">pin_incorrect</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span>
				<span class="n">display_pin_incorrect_message</span><span class="p">());</span>

			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">done_processing</span><span class="p">;</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">cancel_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cancel_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">done_processing</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">getting_pin</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">digit_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">digit_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="kt">unsigned</span> <span class="k">const</span> <span class="n">pin_length</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// 数字密码长度假定为4
</span>			<span class="n">pin</span> <span class="o">+=</span> <span class="n">msg</span><span class="p">.</span><span class="n">digit</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">pin</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="n">pin_length</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="c1">// 向银行去人密码是否正确
</span>				<span class="n">bank</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">verify_pin</span><span class="p">(</span><span class="n">account</span><span class="p">,</span> <span class="n">pin</span><span class="p">,</span> <span class="n">incoming</span><span class="p">));</span>

				<span class="c1">// atm状态迁移为确认密码
</span>				<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">verifying_pin</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">clear_last_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">clear_last_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pin</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="p">{</span>
				<span class="n">pin</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
				<span class="p">)</span>
			<span class="c1">// 取消将退出卡片
</span>			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">cancel_pressed</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cancel_pressed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">done_processing</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">waiting_for_card</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">// 人机交互界面显示插入卡片提示
</span>		<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">display_enter_card</span><span class="p">());</span>

		<span class="c1">// 等待卡片插入
</span>		<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
			<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">card_inserted</span><span class="o">&gt;</span><span class="p">(</span>
				<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">card_inserted</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">account</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="n">account</span><span class="p">;</span> <span class="c1">// 获取卡片账户
</span>			<span class="n">pin</span> <span class="o">=</span> <span class="s">""</span><span class="p">;</span>              <span class="c1">// 等待用户输入密码
</span>
			<span class="c1">// 人机交互界面显示输入密码提示
</span>			<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">display_enter_pin</span><span class="p">());</span>

			<span class="c1">// atm状态迁移为获取密码
</span>			<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">getting_pin</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="nf">done_processing</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">interface_hardware</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">eject_card</span><span class="p">());</span>

		<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">waiting_for_card</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atm</span><span class="p">(</span><span class="n">atm</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">atm</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">atm</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

	<span class="n">atm</span><span class="p">(</span>
		<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">bank_</span><span class="p">,</span>
		<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">interface_hardware_</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">bank</span><span class="p">(</span><span class="n">bank_</span><span class="p">),</span>
		<span class="n">interface_hardware</span><span class="p">(</span><span class="n">interface_hardware_</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="c1">// ATM机坏掉了
</span>	<span class="kt">void</span> <span class="n">done</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">get_sender</span><span class="p">().</span><span class="n">send</span><span class="p">(</span><span class="n">messaging</span><span class="o">::</span><span class="n">close_queue</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">run</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="c1">// 初始状态：等待用户插入卡片
</span>		<span class="n">state</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">waiting_for_card</span><span class="p">;</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(;;)</span>
			<span class="p">{</span>
				<span class="c1">// 循环当前状态
</span>				<span class="p">(</span><span class="k">this</span><span class="o">-&gt;*</span><span class="n">state</span><span class="p">)();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">messaging</span><span class="o">::</span><span class="n">close_queue</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 暴露收件人信息，这样才能向incoming发送邮件
</span>	<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">get_sender</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">incoming</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 银行状态机，从run开始看
</span><span class="k">class</span> <span class="nc">bank</span><span class="n">_machine</span>
<span class="p">{</span>
	<span class="n">messaging</span><span class="o">::</span><span class="n">receiver</span> <span class="n">incoming</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">balance</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>

	<span class="n">bank_machine</span><span class="p">()</span> <span class="o">:</span>
		<span class="n">balance</span><span class="p">(</span><span class="mi">199</span><span class="p">)</span> <span class="c1">// 假定默认余额为199
</span>	<span class="p">{}</span>

	<span class="c1">// 银行破产了
</span>	<span class="kt">void</span> <span class="n">done</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">get_sender</span><span class="p">().</span><span class="n">send</span><span class="p">(</span><span class="n">messaging</span><span class="o">::</span><span class="n">close_queue</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">run</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(;;)</span>
			<span class="p">{</span>
				<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">verify_pin</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">verify_pin</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="n">pin</span> <span class="o">==</span> <span class="s">"1937"</span><span class="p">)</span> <span class="c1">// 默认密码1937
</span>					<span class="p">{</span>
						<span class="n">msg</span><span class="p">.</span><span class="n">atm_queue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">pin_verified</span><span class="p">());</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="n">msg</span><span class="p">.</span><span class="n">atm_queue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">pin_incorrect</span><span class="p">());</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>					
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">withdraw</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="n">withdraw</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>					
					<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">msg</span><span class="p">.</span><span class="n">amount</span><span class="p">)</span>
					<span class="p">{</span>
						<span class="n">msg</span><span class="p">.</span><span class="n">atm_queue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">withdraw_ok</span><span class="p">());</span>
						<span class="k">this</span><span class="o">-&gt;</span><span class="n">balance</span> <span class="o">-=</span> <span class="n">msg</span><span class="p">.</span><span class="n">amount</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span>
					<span class="p">{</span>
						<span class="n">msg</span><span class="p">.</span><span class="n">atm_queue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">withdraw_denied</span><span class="p">());</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">get_balance</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">get_balance</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">msg</span><span class="p">.</span><span class="n">atm_queue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="o">::</span><span class="n">balance</span><span class="p">(</span><span class="n">balance</span><span class="p">));</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">withdrawal_processed</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">withdrawal_processed</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">cancel_withdrawal</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">cancel_withdrawal</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
				<span class="p">}</span>
				<span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">messaging</span><span class="o">::</span><span class="n">close_queue</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">get_sender</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">incoming</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="c1">// 人机交互状态机
</span><span class="k">class</span> <span class="nc">interface</span><span class="n">_machine</span>
<span class="p">{</span>
	<span class="n">messaging</span><span class="o">::</span><span class="n">receiver</span> <span class="n">incoming</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">iom</span><span class="p">;</span> <span class="c1">// cout锁
</span>
<span class="k">public</span><span class="o">:</span>

	<span class="kt">void</span> <span class="n">done</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">get_sender</span><span class="p">().</span><span class="n">send</span><span class="p">(</span><span class="n">messaging</span><span class="o">::</span><span class="n">close_queue</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">run</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">try</span>
		<span class="p">{</span>
			<span class="k">for</span> <span class="p">(;;)</span>
			<span class="p">{</span>
				<span class="n">incoming</span><span class="p">.</span><span class="n">wait</span><span class="p">()</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">issue_money</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">issue_money</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="c1">// 放款显示
</span>					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Issuing "</span>
							<span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">amount</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_insufficient_funds</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_insufficient_funds</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="c1">// 余额不足提示
</span>					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Insufficient funds"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_enter_pin</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_enter_pin</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span>
							<span class="o">&lt;&lt;</span> <span class="s">"Please enter your PIN (0-9)"</span>
							<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_enter_card</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_enter_card</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Please enter your card (I)"</span>
							<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_balance</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_balance</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span>
							<span class="o">&lt;&lt;</span> <span class="s">"The balance of your account is "</span>
							<span class="o">&lt;&lt;</span> <span class="n">msg</span><span class="p">.</span><span class="n">amount</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_withdrawal_options</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_withdrawal_options</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Withdraw 50? (w)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Display Balance? (b)"</span>
							<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cancel? (c)"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_withdrawal_cancelled</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_withdrawal_cancelled</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Withdrawal cancelled"</span>
							<span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">display_pin_incorrect_message</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">display_pin_incorrect_message</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"PIN incorrect"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
						<span class="p">)</span>
					<span class="p">.</span><span class="n">handle</span><span class="o">&lt;</span><span class="n">eject_card</span><span class="o">&gt;</span><span class="p">(</span>
						<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">eject_card</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">msg</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="p">{</span>
						<span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lk</span><span class="p">(</span><span class="n">iom</span><span class="p">);</span>
						<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Ejecting card"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">messaging</span><span class="o">::</span><span class="n">close_queue</span><span class="o">&amp;</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">get_sender</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">incoming</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cp">#endif // _ATM_H_
</span></code></pre>
</div>

<h4 id="source_main_cpp">main.cpp</h4>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="cp">#include &lt;thread&gt;
#include "ATM.h"
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">bank_machine</span> <span class="n">bank</span><span class="p">;</span>
	<span class="n">interface_machine</span> <span class="n">interface_hardware</span><span class="p">;</span>
	<span class="n">atm</span> <span class="n">machine</span><span class="p">(</span><span class="n">bank</span><span class="p">.</span><span class="n">get_sender</span><span class="p">(),</span> <span class="n">interface_hardware</span><span class="p">.</span><span class="n">get_sender</span><span class="p">());</span>

	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">bank_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bank_machine</span><span class="o">::</span><span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bank</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">if_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">interface_machine</span><span class="o">::</span><span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">interface_hardware</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">atm_thread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">atm</span><span class="o">::</span><span class="n">run</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">machine</span><span class="p">);</span>

	<span class="n">messaging</span><span class="o">::</span><span class="n">sender</span> <span class="n">atmqueue</span><span class="p">(</span><span class="n">machine</span><span class="p">.</span><span class="n">get_sender</span><span class="p">());</span>

	<span class="n">bool</span> <span class="n">quit_pressed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit_pressed</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="k">case</span> <span class="sc">'0'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'1'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'2'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'3'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'4'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'5'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'6'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'7'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'8'</span><span class="p">:</span>
		<span class="k">case</span> <span class="sc">'9'</span><span class="p">:</span>
			<span class="n">atmqueue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">digit_pressed</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'b'</span><span class="p">:</span>
			<span class="n">atmqueue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">balance_pressed</span><span class="p">());</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'w'</span><span class="p">:</span>
			<span class="n">atmqueue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">withdraw_pressed</span><span class="p">(</span><span class="mi">50</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'c'</span><span class="p">:</span>
			<span class="n">atmqueue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">cancel_pressed</span><span class="p">());</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'q'</span><span class="p">:</span>
			<span class="n">quit_pressed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="sc">'i'</span><span class="p">:</span>
			<span class="n">atmqueue</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">card_inserted</span><span class="p">(</span><span class="s">"acc1234"</span><span class="p">));</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bank</span><span class="p">.</span><span class="n">done</span><span class="p">();</span>
	<span class="n">machine</span><span class="p">.</span><span class="n">done</span><span class="p">();</span>
	<span class="n">interface_hardware</span><span class="p">.</span><span class="n">done</span><span class="p">();</span>

	<span class="n">atm_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">bank_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
	<span class="n">if_thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<h4 id="atm_result">结果</h4>

<div class="highlighter-rouge"><pre class="highlight"><code>Please enter your card (I)
i
Please enter your PIN (0-9)
1937
Withdraw 50? (w)
Display Balance? (b)
Cancel? (c)
b
The balance of your account is 199
Withdraw 50? (w)
Display Balance? (b)
Cancel? (c)
w
Issuing 50
Withdraw 50? (w)
Display Balance? (b)
Cancel? (c)
b
The balance of your account is 149
Withdraw 50? (w)
Display Balance? (b)
Cancel? (c)
c
Ejecting card
Please enter your card (I)
^C
</code></pre>
</div>


                <hr>



                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2017/04/21/C++-basis-4/" data-toggle="tooltip" data-placement="top" title="C++ 释疑（四）">
                        Previous<br>
                        <span>C++ 释疑（四）</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2017/05/24/C++-thread-design-1/" data-toggle="tooltip" data-placement="top" title="C++ 多线程设计（一）">
                        Next<br>
                        <span>C++ 多线程设计（一）</span>
                        </a>
                    </li>
                    
                </ul>



                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

            </div>

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#Python" title="Python" rel="1">
                                    Python
                                </a>
                            
        				
                            
                				<a href="/tags/#Markdown" title="Markdown" rel="1">
                                    Markdown
                                </a>
                            
        				
                            
                				<a href="/tags/#C++" title="C++" rel="9">
                                    C++
                                </a>
                            
        				
                            
                				<a href="/tags/#C++ primer" title="C++ primer" rel="4">
                                    C++ primer
                                </a>
                            
        				
                            
                				<a href="/tags/#thread" title="thread" rel="4">
                                    thread
                                </a>
                            
        				
                            
                				<a href="/tags/#Qt5" title="Qt5" rel="1">
                                    Qt5
                                </a>
                            
        				
                            
                				<a href="/tags/#git" title="git" rel="1">
                                    git
                                </a>
                            
        				
                            
                				<a href="/tags/#shell" title="shell" rel="1">
                                    shell
                                </a>
                            
        				
                            
                				<a href="/tags/#algorithm" title="algorithm" rel="1">
                                    algorithm
                                </a>
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://huangxuan.me">Hux Blog</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>





<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "blog-pengzhen";
    var disqus_identifier = "/2017/04/24/C++-thread-basis";
    var disqus_url = "https://chorior.github.io/2017/04/24/C++-thread-basis/";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->






    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                     
                    <li>
                        <a href="/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/Chorior">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/Chorior">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Chorior 2019
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> |
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=huxpro&repo=huxpro.github.io&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-92626017-1';
    var _gaDomain = 'auto';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->




<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>




<!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0" /> -->
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
